// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pb "github.com/outcaste-io/badger/v3/pb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DirectedEdge_Op int32

const (
	DirectedEdge_SET DirectedEdge_Op = 0
	DirectedEdge_DEL DirectedEdge_Op = 1
)

var DirectedEdge_Op_name = map[int32]string{
	0: "SET",
	1: "DEL",
}

var DirectedEdge_Op_value = map[string]int32{
	"SET": 0,
	"DEL": 1,
}

func (x DirectedEdge_Op) String() string {
	return proto.EnumName(DirectedEdge_Op_name, int32(x))
}

func (DirectedEdge_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{15, 0}
}

type Mutations_DropOp int32

const (
	Mutations_NONE Mutations_DropOp = 0
	Mutations_ALL  Mutations_DropOp = 1
	Mutations_DATA Mutations_DropOp = 2
)

var Mutations_DropOp_name = map[int32]string{
	0: "NONE",
	1: "ALL",
	2: "DATA",
}

var Mutations_DropOp_value = map[string]int32{
	"NONE": 0,
	"ALL":  1,
	"DATA": 2,
}

func (x Mutations_DropOp) String() string {
	return proto.EnumName(Mutations_DropOp_name, int32(x))
}

func (Mutations_DropOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{16, 0}
}

type Posting_ValType int32

const (
	Posting_DEFAULT  Posting_ValType = 0
	Posting_BINARY   Posting_ValType = 1
	Posting_INT      Posting_ValType = 2
	Posting_FLOAT    Posting_ValType = 3
	Posting_BOOL     Posting_ValType = 4
	Posting_DATETIME Posting_ValType = 5
	Posting_GEO      Posting_ValType = 6
	Posting_UID      Posting_ValType = 7
	Posting_PASSWORD Posting_ValType = 8
	Posting_STRING   Posting_ValType = 9
	Posting_OBJECT   Posting_ValType = 10
)

var Posting_ValType_name = map[int32]string{
	0:  "DEFAULT",
	1:  "BINARY",
	2:  "INT",
	3:  "FLOAT",
	4:  "BOOL",
	5:  "DATETIME",
	6:  "GEO",
	7:  "UID",
	8:  "PASSWORD",
	9:  "STRING",
	10: "OBJECT",
}

var Posting_ValType_value = map[string]int32{
	"DEFAULT":  0,
	"BINARY":   1,
	"INT":      2,
	"FLOAT":    3,
	"BOOL":     4,
	"DATETIME": 5,
	"GEO":      6,
	"UID":      7,
	"PASSWORD": 8,
	"STRING":   9,
	"OBJECT":   10,
}

func (x Posting_ValType) String() string {
	return proto.EnumName(Posting_ValType_name, int32(x))
}

func (Posting_ValType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22, 0}
}

type Posting_PostingType int32

const (
	Posting_REF   Posting_PostingType = 0
	Posting_VALUE Posting_PostingType = 1
)

var Posting_PostingType_name = map[int32]string{
	0: "REF",
	1: "VALUE",
}

var Posting_PostingType_value = map[string]int32{
	"REF":   0,
	"VALUE": 1,
}

func (x Posting_PostingType) String() string {
	return proto.EnumName(Posting_PostingType_name, int32(x))
}

func (Posting_PostingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22, 1}
}

type SchemaUpdate_Directive int32

const (
	SchemaUpdate_NONE   SchemaUpdate_Directive = 0
	SchemaUpdate_INDEX  SchemaUpdate_Directive = 1
	SchemaUpdate_DELETE SchemaUpdate_Directive = 3
)

var SchemaUpdate_Directive_name = map[int32]string{
	0: "NONE",
	1: "INDEX",
	3: "DELETE",
}

var SchemaUpdate_Directive_value = map[string]int32{
	"NONE":   0,
	"INDEX":  1,
	"DELETE": 3,
}

func (x SchemaUpdate_Directive) String() string {
	return proto.EnumName(SchemaUpdate_Directive_name, int32(x))
}

func (SchemaUpdate_Directive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{29, 0}
}

type Request_RespFormat int32

const (
	Request_JSON Request_RespFormat = 0
	Request_RDF  Request_RespFormat = 1
)

var Request_RespFormat_name = map[int32]string{
	0: "JSON",
	1: "RDF",
}

var Request_RespFormat_value = map[string]int32{
	"JSON": 0,
	"RDF":  1,
}

func (x Request_RespFormat) String() string {
	return proto.EnumName(Request_RespFormat_name, int32(x))
}

func (Request_RespFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{36, 0}
}

type Operation_DropOp int32

const (
	Operation_NONE Operation_DropOp = 0
	Operation_ALL  Operation_DropOp = 1
	Operation_DATA Operation_DropOp = 2
	Operation_ATTR Operation_DropOp = 3
)

var Operation_DropOp_name = map[int32]string{
	0: "NONE",
	1: "ALL",
	2: "DATA",
	3: "ATTR",
}

var Operation_DropOp_value = map[string]int32{
	"NONE": 0,
	"ALL":  1,
	"DATA": 2,
	"ATTR": 3,
}

func (x Operation_DropOp) String() string {
	return proto.EnumName(Operation_DropOp_name, int32(x))
}

func (Operation_DropOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{41, 0}
}

type NumLeaseType int32

const (
	Num_NS_ID  NumLeaseType = 0
	Num_UID    NumLeaseType = 1
	Num_UNUSED NumLeaseType = 2
)

var NumLeaseType_name = map[int32]string{
	0: "NS_ID",
	1: "UID",
	2: "UNUSED",
}

var NumLeaseType_value = map[string]int32{
	"NS_ID":  0,
	"UID":    1,
	"UNUSED": 2,
}

func (x NumLeaseType) String() string {
	return proto.EnumName(NumLeaseType_name, int32(x))
}

func (NumLeaseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{54, 0}
}

type UpdateGraphQLSchemaRequest_Op int32

const (
	UpdateGraphQLSchemaRequest_SCHEMA UpdateGraphQLSchemaRequest_Op = 0
	UpdateGraphQLSchemaRequest_SCRIPT UpdateGraphQLSchemaRequest_Op = 1
)

var UpdateGraphQLSchemaRequest_Op_name = map[int32]string{
	0: "SCHEMA",
	1: "SCRIPT",
}

var UpdateGraphQLSchemaRequest_Op_value = map[string]int32{
	"SCHEMA": 0,
	"SCRIPT": 1,
}

func (x UpdateGraphQLSchemaRequest_Op) String() string {
	return proto.EnumName(UpdateGraphQLSchemaRequest_Op_name, int32(x))
}

func (UpdateGraphQLSchemaRequest_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{62, 0}
}

type List struct {
	// repeated fixed64 uids = 1; *1/
	Bitmap     []byte   `protobuf:"bytes,2,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	SortedUids []uint64 `protobuf:"fixed64,3,rep,packed,name=sortedUids,proto3" json:"sortedUids,omitempty"`
}

func (m *List) Reset()         { *m = List{} }
func (m *List) String() string { return proto.CompactTextString(m) }
func (*List) ProtoMessage()    {}
func (*List) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}
func (m *List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_List.Merge(m, src)
}
func (m *List) XXX_Size() int {
	return m.Size()
}
func (m *List) XXX_DiscardUnknown() {
	xxx_messageInfo_List.DiscardUnknown(m)
}

var xxx_messageInfo_List proto.InternalMessageInfo

func (m *List) GetBitmap() []byte {
	if m != nil {
		return m.Bitmap
	}
	return nil
}

func (m *List) GetSortedUids() []uint64 {
	if m != nil {
		return m.SortedUids
	}
	return nil
}

type TaskValue struct {
	Val     []byte          `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty"`
	ValType Posting_ValType `protobuf:"varint,2,opt,name=val_type,json=valType,proto3,enum=pb.Posting_ValType" json:"val_type,omitempty"`
}

func (m *TaskValue) Reset()         { *m = TaskValue{} }
func (m *TaskValue) String() string { return proto.CompactTextString(m) }
func (*TaskValue) ProtoMessage()    {}
func (*TaskValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}
func (m *TaskValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskValue.Merge(m, src)
}
func (m *TaskValue) XXX_Size() int {
	return m.Size()
}
func (m *TaskValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskValue.DiscardUnknown(m)
}

var xxx_messageInfo_TaskValue proto.InternalMessageInfo

func (m *TaskValue) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *TaskValue) GetValType() Posting_ValType {
	if m != nil {
		return m.ValType
	}
	return Posting_DEFAULT
}

type SrcFunction struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args    []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	IsCount bool     `protobuf:"varint,4,opt,name=isCount,proto3" json:"isCount,omitempty"`
}

func (m *SrcFunction) Reset()         { *m = SrcFunction{} }
func (m *SrcFunction) String() string { return proto.CompactTextString(m) }
func (*SrcFunction) ProtoMessage()    {}
func (*SrcFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}
func (m *SrcFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SrcFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SrcFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SrcFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SrcFunction.Merge(m, src)
}
func (m *SrcFunction) XXX_Size() int {
	return m.Size()
}
func (m *SrcFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SrcFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SrcFunction proto.InternalMessageInfo

func (m *SrcFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SrcFunction) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *SrcFunction) GetIsCount() bool {
	if m != nil {
		return m.IsCount
	}
	return false
}

type Query struct {
	Attr     string `protobuf:"bytes,1,opt,name=attr,proto3" json:"attr,omitempty"`
	AfterUid uint64 `protobuf:"fixed64,3,opt,name=after_uid,json=afterUid,proto3" json:"after_uid,omitempty"`
	DoCount  bool   `protobuf:"varint,4,opt,name=do_count,json=doCount,proto3" json:"do_count,omitempty"`
	// Exactly one of uids and terms is populated.
	UidList *List `protobuf:"bytes,5,opt,name=uid_list,json=uidList,proto3" json:"uid_list,omitempty"`
	// Function to generate or filter UIDs.
	SrcFunc *SrcFunction `protobuf:"bytes,6,opt,name=src_func,json=srcFunc,proto3" json:"src_func,omitempty"`
	// Expand all language variants.
	ExpandAll bool   `protobuf:"varint,10,opt,name=expand_all,json=expandAll,proto3" json:"expand_all,omitempty"`
	ReadTs    uint64 `protobuf:"varint,13,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	Cache     int32  `protobuf:"varint,14,opt,name=cache,proto3" json:"cache,omitempty"`
	// Used to limit the number of result. Typically, the count is value of first
	// field. Now, It's been used only for has query.
	First int32 `protobuf:"varint,15,opt,name=first,proto3" json:"first,omitempty"`
	// Offset helps in fetching lesser results for the has query when there is no
	// filter and order.
	Offset int32 `protobuf:"varint,16,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.Size()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *Query) GetAfterUid() uint64 {
	if m != nil {
		return m.AfterUid
	}
	return 0
}

func (m *Query) GetDoCount() bool {
	if m != nil {
		return m.DoCount
	}
	return false
}

func (m *Query) GetUidList() *List {
	if m != nil {
		return m.UidList
	}
	return nil
}

func (m *Query) GetSrcFunc() *SrcFunction {
	if m != nil {
		return m.SrcFunc
	}
	return nil
}

func (m *Query) GetExpandAll() bool {
	if m != nil {
		return m.ExpandAll
	}
	return false
}

func (m *Query) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Query) GetCache() int32 {
	if m != nil {
		return m.Cache
	}
	return 0
}

func (m *Query) GetFirst() int32 {
	if m != nil {
		return m.First
	}
	return 0
}

func (m *Query) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type ValueList struct {
	Values []*TaskValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *ValueList) Reset()         { *m = ValueList{} }
func (m *ValueList) String() string { return proto.CompactTextString(m) }
func (*ValueList) ProtoMessage()    {}
func (*ValueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{4}
}
func (m *ValueList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueList.Merge(m, src)
}
func (m *ValueList) XXX_Size() int {
	return m.Size()
}
func (m *ValueList) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueList.DiscardUnknown(m)
}

var xxx_messageInfo_ValueList proto.InternalMessageInfo

func (m *ValueList) GetValues() []*TaskValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type Result struct {
	UidMatrix     []*List      `protobuf:"bytes,1,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	ValueMatrix   []*ValueList `protobuf:"bytes,2,rep,name=value_matrix,json=valueMatrix,proto3" json:"value_matrix,omitempty"`
	Counts        []uint32     `protobuf:"varint,3,rep,packed,name=counts,proto3" json:"counts,omitempty"`
	IntersectDest bool         `protobuf:"varint,4,opt,name=intersect_dest,json=intersectDest,proto3" json:"intersect_dest,omitempty"`
	List          bool         `protobuf:"varint,7,opt,name=list,proto3" json:"list,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{5}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

func (m *Result) GetValueMatrix() []*ValueList {
	if m != nil {
		return m.ValueMatrix
	}
	return nil
}

func (m *Result) GetCounts() []uint32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

func (m *Result) GetIntersectDest() bool {
	if m != nil {
		return m.IntersectDest
	}
	return false
}

func (m *Result) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

type Order struct {
	Attr string `protobuf:"bytes,1,opt,name=attr,proto3" json:"attr,omitempty"`
	Desc bool   `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{6}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *Order) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

type SortMessage struct {
	Order     []*Order `protobuf:"bytes,1,rep,name=order,proto3" json:"order,omitempty"`
	UidMatrix []*List  `protobuf:"bytes,2,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	Count     int32    `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	Offset    int32    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	ReadTs    uint64   `protobuf:"varint,13,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
}

func (m *SortMessage) Reset()         { *m = SortMessage{} }
func (m *SortMessage) String() string { return proto.CompactTextString(m) }
func (*SortMessage) ProtoMessage()    {}
func (*SortMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{7}
}
func (m *SortMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortMessage.Merge(m, src)
}
func (m *SortMessage) XXX_Size() int {
	return m.Size()
}
func (m *SortMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SortMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SortMessage proto.InternalMessageInfo

func (m *SortMessage) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *SortMessage) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

func (m *SortMessage) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SortMessage) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SortMessage) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

type SortResult struct {
	UidMatrix []*List `protobuf:"bytes,1,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
}

func (m *SortResult) Reset()         { *m = SortResult{} }
func (m *SortResult) String() string { return proto.CompactTextString(m) }
func (*SortResult) ProtoMessage()    {}
func (*SortResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{8}
}
func (m *SortResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortResult.Merge(m, src)
}
func (m *SortResult) XXX_Size() int {
	return m.Size()
}
func (m *SortResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SortResult.DiscardUnknown(m)
}

var xxx_messageInfo_SortResult proto.InternalMessageInfo

func (m *SortResult) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

type RaftContext struct {
	WhoIs      string `protobuf:"bytes,1,opt,name=who_is,json=whoIs,proto3" json:"who_is,omitempty"`
	Id         uint64 `protobuf:"fixed64,2,opt,name=id,proto3" json:"id,omitempty"`
	Group      uint32 `protobuf:"varint,3,opt,name=group,proto3" json:"group,omitempty"`
	Addr       string `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr,omitempty"`
	SnapshotTs uint64 `protobuf:"varint,5,opt,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty"`
	IsLearner  bool   `protobuf:"varint,6,opt,name=is_learner,json=isLearner,proto3" json:"is_learner,omitempty"`
}

func (m *RaftContext) Reset()         { *m = RaftContext{} }
func (m *RaftContext) String() string { return proto.CompactTextString(m) }
func (*RaftContext) ProtoMessage()    {}
func (*RaftContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{9}
}
func (m *RaftContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftContext.Merge(m, src)
}
func (m *RaftContext) XXX_Size() int {
	return m.Size()
}
func (m *RaftContext) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftContext.DiscardUnknown(m)
}

var xxx_messageInfo_RaftContext proto.InternalMessageInfo

func (m *RaftContext) GetWhoIs() string {
	if m != nil {
		return m.WhoIs
	}
	return ""
}

func (m *RaftContext) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaftContext) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *RaftContext) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *RaftContext) GetSnapshotTs() uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return 0
}

func (m *RaftContext) GetIsLearner() bool {
	if m != nil {
		return m.IsLearner
	}
	return false
}

// Member stores information about RAFT group member for a single RAFT node.
// Note that each server can be serving multiple RAFT groups. Each group would
// have one RAFT node per server serving that group.
type Member struct {
	Id         uint64 `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupId    uint32 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"groupId,omitempty"`
	Addr       string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Leader     bool   `protobuf:"varint,4,opt,name=leader,proto3" json:"leader,omitempty"`
	AmDead     bool   `protobuf:"varint,5,opt,name=am_dead,json=amDead,proto3" json:"amDead,omitempty"`
	LastUpdate uint64 `protobuf:"varint,6,opt,name=last_update,json=lastUpdate,proto3" json:"lastUpdate,omitempty"`
	Learner    bool   `protobuf:"varint,7,opt,name=learner,proto3" json:"learner,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{10}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Member) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Member) GetLeader() bool {
	if m != nil {
		return m.Leader
	}
	return false
}

func (m *Member) GetAmDead() bool {
	if m != nil {
		return m.AmDead
	}
	return false
}

func (m *Member) GetLastUpdate() uint64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Member) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

type ZeroProposal struct {
	SnapshotTs  map[uint32]uint64 `protobuf:"bytes,1,rep,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Member      *Member           `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
	Tablets     []*Tablet         `protobuf:"bytes,3,rep,name=tablets,proto3" json:"tablets,omitempty"`
	NumUids     uint32            `protobuf:"varint,4,opt,name=num_uids,json=numUids,proto3" json:"num_uids,omitempty"`
	NumNsids    uint32            `protobuf:"varint,5,opt,name=num_nsids,json=numNsids,proto3" json:"num_nsids,omitempty"`
	Cid         string            `protobuf:"bytes,6,opt,name=cid,proto3" json:"cid,omitempty"`
	DeleteNs    *DeleteNsRequest  `protobuf:"bytes,7,opt,name=delete_ns,json=deleteNs,proto3" json:"delete_ns,omitempty"`
	CpuHours    float64           `protobuf:"fixed64,8,opt,name=cpu_hours,json=cpuHours,proto3" json:"cpu_hours,omitempty"`
	LastCharged int64             `protobuf:"varint,9,opt,name=last_charged,json=lastCharged,proto3" json:"last_charged,omitempty"`
}

func (m *ZeroProposal) Reset()         { *m = ZeroProposal{} }
func (m *ZeroProposal) String() string { return proto.CompactTextString(m) }
func (*ZeroProposal) ProtoMessage()    {}
func (*ZeroProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{11}
}
func (m *ZeroProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroProposal.Merge(m, src)
}
func (m *ZeroProposal) XXX_Size() int {
	return m.Size()
}
func (m *ZeroProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroProposal proto.InternalMessageInfo

func (m *ZeroProposal) GetSnapshotTs() map[uint32]uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return nil
}

func (m *ZeroProposal) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *ZeroProposal) GetTablets() []*Tablet {
	if m != nil {
		return m.Tablets
	}
	return nil
}

func (m *ZeroProposal) GetNumUids() uint32 {
	if m != nil {
		return m.NumUids
	}
	return 0
}

func (m *ZeroProposal) GetNumNsids() uint32 {
	if m != nil {
		return m.NumNsids
	}
	return 0
}

func (m *ZeroProposal) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *ZeroProposal) GetDeleteNs() *DeleteNsRequest {
	if m != nil {
		return m.DeleteNs
	}
	return nil
}

func (m *ZeroProposal) GetCpuHours() float64 {
	if m != nil {
		return m.CpuHours
	}
	return 0
}

func (m *ZeroProposal) GetLastCharged() int64 {
	if m != nil {
		return m.LastCharged
	}
	return 0
}

// MembershipState is used to pack together the current membership state of all
// the nodes in the caller server; and the membership updates recorded by the
// callee server since the provided lastUpdate.
type MembershipState struct {
	Members     map[uint64]*Member `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tablets     map[string]*Tablet `protobuf:"bytes,2,rep,name=tablets,proto3" json:"tablets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Removed     []uint64           `protobuf:"varint,3,rep,packed,name=removed,proto3" json:"removed,omitempty"`
	RaftIndex   uint64             `protobuf:"varint,5,opt,name=raft_index,json=raftIndex,proto3" json:"raft_index,omitempty"`
	MaxUID      uint64             `protobuf:"varint,6,opt,name=maxUID,proto3" json:"maxUID,omitempty"`
	MaxNsID     uint64             `protobuf:"varint,7,opt,name=maxNsID,proto3" json:"maxNsID,omitempty"`
	Cid         string             `protobuf:"bytes,8,opt,name=cid,proto3" json:"cid,omitempty"`
	CpuHours    float64            `protobuf:"fixed64,9,opt,name=cpu_hours,json=cpuHours,proto3" json:"cpu_hours,omitempty"`
	LastCharged int64              `protobuf:"varint,10,opt,name=last_charged,json=lastCharged,proto3" json:"last_charged,omitempty"`
}

func (m *MembershipState) Reset()         { *m = MembershipState{} }
func (m *MembershipState) String() string { return proto.CompactTextString(m) }
func (*MembershipState) ProtoMessage()    {}
func (*MembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{12}
}
func (m *MembershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MembershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MembershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MembershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MembershipState.Merge(m, src)
}
func (m *MembershipState) XXX_Size() int {
	return m.Size()
}
func (m *MembershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_MembershipState.DiscardUnknown(m)
}

var xxx_messageInfo_MembershipState proto.InternalMessageInfo

func (m *MembershipState) GetMembers() map[uint64]*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *MembershipState) GetTablets() map[string]*Tablet {
	if m != nil {
		return m.Tablets
	}
	return nil
}

func (m *MembershipState) GetRemoved() []uint64 {
	if m != nil {
		return m.Removed
	}
	return nil
}

func (m *MembershipState) GetRaftIndex() uint64 {
	if m != nil {
		return m.RaftIndex
	}
	return 0
}

func (m *MembershipState) GetMaxUID() uint64 {
	if m != nil {
		return m.MaxUID
	}
	return 0
}

func (m *MembershipState) GetMaxNsID() uint64 {
	if m != nil {
		return m.MaxNsID
	}
	return 0
}

func (m *MembershipState) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *MembershipState) GetCpuHours() float64 {
	if m != nil {
		return m.CpuHours
	}
	return 0
}

func (m *MembershipState) GetLastCharged() int64 {
	if m != nil {
		return m.LastCharged
	}
	return 0
}

type HealthInfo struct {
	Instance string   `protobuf:"bytes,1,opt,name=instance,proto3" json:"instance,omitempty"`
	Address  string   `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Status   string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	Group    string   `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	Version  string   `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	Uptime   int64    `protobuf:"varint,6,opt,name=uptime,proto3" json:"uptime,omitempty"`
	LastEcho int64    `protobuf:"varint,7,opt,name=lastEcho,proto3" json:"lastEcho,omitempty"`
	ReadTs   uint64   `protobuf:"varint,8,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	Ongoing  []string `protobuf:"bytes,9,rep,name=ongoing,proto3" json:"ongoing,omitempty"`
	Indexing []string `protobuf:"bytes,10,rep,name=indexing,proto3" json:"indexing,omitempty"`
}

func (m *HealthInfo) Reset()         { *m = HealthInfo{} }
func (m *HealthInfo) String() string { return proto.CompactTextString(m) }
func (*HealthInfo) ProtoMessage()    {}
func (*HealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{13}
}
func (m *HealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthInfo.Merge(m, src)
}
func (m *HealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *HealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HealthInfo proto.InternalMessageInfo

func (m *HealthInfo) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *HealthInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *HealthInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *HealthInfo) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *HealthInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *HealthInfo) GetUptime() int64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *HealthInfo) GetLastEcho() int64 {
	if m != nil {
		return m.LastEcho
	}
	return 0
}

func (m *HealthInfo) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *HealthInfo) GetOngoing() []string {
	if m != nil {
		return m.Ongoing
	}
	return nil
}

func (m *HealthInfo) GetIndexing() []string {
	if m != nil {
		return m.Indexing
	}
	return nil
}

type Tablet struct {
	// Served by which group.
	GroupId     uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"groupId,omitempty"`
	Predicate   string `protobuf:"bytes,2,opt,name=predicate,proto3" json:"predicate,omitempty"`
	Force       bool   `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	OnDiskBytes int64  `protobuf:"varint,7,opt,name=on_disk_bytes,json=onDiskBytes,proto3" json:"on_disk_bytes,omitempty"`
	Remove      bool   `protobuf:"varint,8,opt,name=remove,proto3" json:"remove,omitempty"`
	// If true, do not ask zero to serve any tablets.
	ReadOnly bool   `protobuf:"varint,9,opt,name=read_only,json=readOnly,proto3" json:"readOnly,omitempty"`
	MoveTs   uint64 `protobuf:"varint,10,opt,name=move_ts,json=moveTs,proto3" json:"moveTs,omitempty"`
	// Estimated uncompressed size of tablet in bytes
	UncompressedBytes int64 `protobuf:"varint,11,opt,name=uncompressed_bytes,json=uncompressedBytes,proto3" json:"uncompressed_bytes,omitempty"`
}

func (m *Tablet) Reset()         { *m = Tablet{} }
func (m *Tablet) String() string { return proto.CompactTextString(m) }
func (*Tablet) ProtoMessage()    {}
func (*Tablet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{14}
}
func (m *Tablet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tablet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tablet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tablet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tablet.Merge(m, src)
}
func (m *Tablet) XXX_Size() int {
	return m.Size()
}
func (m *Tablet) XXX_DiscardUnknown() {
	xxx_messageInfo_Tablet.DiscardUnknown(m)
}

var xxx_messageInfo_Tablet proto.InternalMessageInfo

func (m *Tablet) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Tablet) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *Tablet) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *Tablet) GetOnDiskBytes() int64 {
	if m != nil {
		return m.OnDiskBytes
	}
	return 0
}

func (m *Tablet) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *Tablet) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Tablet) GetMoveTs() uint64 {
	if m != nil {
		return m.MoveTs
	}
	return 0
}

func (m *Tablet) GetUncompressedBytes() int64 {
	if m != nil {
		return m.UncompressedBytes
	}
	return 0
}

type DirectedEdge struct {
	Entity       uint64          `protobuf:"fixed64,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Attr         string          `protobuf:"bytes,2,opt,name=attr,proto3" json:"attr,omitempty"`
	Value        []byte          `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ValueType    Posting_ValType `protobuf:"varint,4,opt,name=value_type,json=valueType,proto3,enum=pb.Posting_ValType" json:"value_type,omitempty"`
	ValueId      uint64          `protobuf:"fixed64,5,opt,name=value_id,json=valueId,proto3" json:"value_id,omitempty"`
	Op           DirectedEdge_Op `protobuf:"varint,8,opt,name=op,proto3,enum=pb.DirectedEdge_Op" json:"op,omitempty"`
	AllowedPreds []string        `protobuf:"bytes,10,rep,name=allowedPreds,proto3" json:"allowedPreds,omitempty"`
	Namespace    uint64          `protobuf:"varint,11,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *DirectedEdge) Reset()         { *m = DirectedEdge{} }
func (m *DirectedEdge) String() string { return proto.CompactTextString(m) }
func (*DirectedEdge) ProtoMessage()    {}
func (*DirectedEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{15}
}
func (m *DirectedEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectedEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectedEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectedEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectedEdge.Merge(m, src)
}
func (m *DirectedEdge) XXX_Size() int {
	return m.Size()
}
func (m *DirectedEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectedEdge.DiscardUnknown(m)
}

var xxx_messageInfo_DirectedEdge proto.InternalMessageInfo

func (m *DirectedEdge) GetEntity() uint64 {
	if m != nil {
		return m.Entity
	}
	return 0
}

func (m *DirectedEdge) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *DirectedEdge) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DirectedEdge) GetValueType() Posting_ValType {
	if m != nil {
		return m.ValueType
	}
	return Posting_DEFAULT
}

func (m *DirectedEdge) GetValueId() uint64 {
	if m != nil {
		return m.ValueId
	}
	return 0
}

func (m *DirectedEdge) GetOp() DirectedEdge_Op {
	if m != nil {
		return m.Op
	}
	return DirectedEdge_SET
}

func (m *DirectedEdge) GetAllowedPreds() []string {
	if m != nil {
		return m.AllowedPreds
	}
	return nil
}

func (m *DirectedEdge) GetNamespace() uint64 {
	if m != nil {
		return m.Namespace
	}
	return 0
}

type Mutations struct {
	GroupId   uint32           `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Edges     []*DirectedEdge  `protobuf:"bytes,3,rep,name=edges,proto3" json:"edges,omitempty"`
	Schema    []*SchemaUpdate  `protobuf:"bytes,4,rep,name=schema,proto3" json:"schema,omitempty"`
	DropOp    Mutations_DropOp `protobuf:"varint,7,opt,name=drop_op,json=dropOp,proto3,enum=pb.Mutations_DropOp" json:"drop_op,omitempty"`
	DropValue string           `protobuf:"bytes,8,opt,name=drop_value,json=dropValue,proto3" json:"drop_value,omitempty"`
}

func (m *Mutations) Reset()         { *m = Mutations{} }
func (m *Mutations) String() string { return proto.CompactTextString(m) }
func (*Mutations) ProtoMessage()    {}
func (*Mutations) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{16}
}
func (m *Mutations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mutations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mutations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutations.Merge(m, src)
}
func (m *Mutations) XXX_Size() int {
	return m.Size()
}
func (m *Mutations) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutations.DiscardUnknown(m)
}

var xxx_messageInfo_Mutations proto.InternalMessageInfo

func (m *Mutations) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Mutations) GetEdges() []*DirectedEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *Mutations) GetSchema() []*SchemaUpdate {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *Mutations) GetDropOp() Mutations_DropOp {
	if m != nil {
		return m.DropOp
	}
	return Mutations_NONE
}

func (m *Mutations) GetDropValue() string {
	if m != nil {
		return m.DropValue
	}
	return ""
}

type Snapshot struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Index   uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	BaseTs  uint64       `protobuf:"varint,3,opt,name=base_ts,json=baseTs,proto3" json:"base_ts,omitempty"`
	// done is used to indicate that snapshot stream was a success.
	Done bool `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
	// since_ts stores the ts of the last snapshot to support diff snap updates.
	SinceTs uint64 `protobuf:"varint,5,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{17}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetBaseTs() uint64 {
	if m != nil {
		return m.BaseTs
	}
	return 0
}

func (m *Snapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *Snapshot) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

type ZeroSnapshot struct {
	Index        uint64           `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	CheckpointTs uint64           `protobuf:"varint,2,opt,name=checkpoint_ts,json=checkpointTs,proto3" json:"checkpoint_ts,omitempty"`
	State        *MembershipState `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *ZeroSnapshot) Reset()         { *m = ZeroSnapshot{} }
func (m *ZeroSnapshot) String() string { return proto.CompactTextString(m) }
func (*ZeroSnapshot) ProtoMessage()    {}
func (*ZeroSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{18}
}
func (m *ZeroSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroSnapshot.Merge(m, src)
}
func (m *ZeroSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ZeroSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroSnapshot proto.InternalMessageInfo

func (m *ZeroSnapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ZeroSnapshot) GetCheckpointTs() uint64 {
	if m != nil {
		return m.CheckpointTs
	}
	return 0
}

func (m *ZeroSnapshot) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

type Proposal struct {
	BaseTimestamp uint64     `protobuf:"varint,1,opt,name=base_timestamp,json=baseTimestamp,proto3" json:"base_timestamp,omitempty"`
	Mutations     *Mutations `protobuf:"bytes,2,opt,name=mutations,proto3" json:"mutations,omitempty"`
	Kv            []*pb.KV   `protobuf:"bytes,4,rep,name=kv,proto3" json:"kv,omitempty"`
	// Delete the predicate which was moved to other group.
	CleanPredicate string    `protobuf:"bytes,6,opt,name=clean_predicate,json=cleanPredicate,proto3" json:"clean_predicate,omitempty"`
	Snapshot       *Snapshot `protobuf:"bytes,9,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	// Block an operation until membership reaches this checksum.
	ExpectedChecksum uint64           `protobuf:"varint,11,opt,name=expected_checksum,json=expectedChecksum,proto3" json:"expected_checksum,omitempty"`
	CdcState         *CDCState        `protobuf:"bytes,13,opt,name=cdc_state,json=cdcState,proto3" json:"cdc_state,omitempty"`
	DeleteNs         *DeleteNsRequest `protobuf:"bytes,14,opt,name=delete_ns,json=deleteNs,proto3" json:"delete_ns,omitempty"`
	// These following are used during processing.
	Index     uint64 `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	Key       uint64 `protobuf:"varint,15,opt,name=key,proto3" json:"key,omitempty"`
	ReadTs    uint64 `protobuf:"varint,16,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	CommitTs  uint64 `protobuf:"varint,17,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	EntrySize int64  `protobuf:"varint,18,opt,name=entry_size,json=entrySize,proto3" json:"entry_size,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{19}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetBaseTimestamp() uint64 {
	if m != nil {
		return m.BaseTimestamp
	}
	return 0
}

func (m *Proposal) GetMutations() *Mutations {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *Proposal) GetKv() []*pb.KV {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *Proposal) GetCleanPredicate() string {
	if m != nil {
		return m.CleanPredicate
	}
	return ""
}

func (m *Proposal) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *Proposal) GetExpectedChecksum() uint64 {
	if m != nil {
		return m.ExpectedChecksum
	}
	return 0
}

func (m *Proposal) GetCdcState() *CDCState {
	if m != nil {
		return m.CdcState
	}
	return nil
}

func (m *Proposal) GetDeleteNs() *DeleteNsRequest {
	if m != nil {
		return m.DeleteNs
	}
	return nil
}

func (m *Proposal) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Proposal) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Proposal) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Proposal) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *Proposal) GetEntrySize() int64 {
	if m != nil {
		return m.EntrySize
	}
	return 0
}

type CDCState struct {
	SentTs uint64 `protobuf:"varint,1,opt,name=sent_ts,json=sentTs,proto3" json:"sent_ts,omitempty"`
}

func (m *CDCState) Reset()         { *m = CDCState{} }
func (m *CDCState) String() string { return proto.CompactTextString(m) }
func (*CDCState) ProtoMessage()    {}
func (*CDCState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{20}
}
func (m *CDCState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDCState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDCState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDCState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDCState.Merge(m, src)
}
func (m *CDCState) XXX_Size() int {
	return m.Size()
}
func (m *CDCState) XXX_DiscardUnknown() {
	xxx_messageInfo_CDCState.DiscardUnknown(m)
}

var xxx_messageInfo_CDCState proto.InternalMessageInfo

func (m *CDCState) GetSentTs() uint64 {
	if m != nil {
		return m.SentTs
	}
	return 0
}

type KVS struct {
	Data []byte `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	// Done used to indicate if the stream of KVS is over.
	Done bool `protobuf:"varint,2,opt,name=done,proto3" json:"done,omitempty"`
	// Predicates is the list of predicates known by the leader at the time of the
	// snapshot.
	Predicates []string `protobuf:"bytes,3,rep,name=predicates,proto3" json:"predicates,omitempty"`
}

func (m *KVS) Reset()         { *m = KVS{} }
func (m *KVS) String() string { return proto.CompactTextString(m) }
func (*KVS) ProtoMessage()    {}
func (*KVS) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{21}
}
func (m *KVS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVS.Merge(m, src)
}
func (m *KVS) XXX_Size() int {
	return m.Size()
}
func (m *KVS) XXX_DiscardUnknown() {
	xxx_messageInfo_KVS.DiscardUnknown(m)
}

var xxx_messageInfo_KVS proto.InternalMessageInfo

func (m *KVS) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *KVS) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *KVS) GetPredicates() []string {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// Posting messages.
type Posting struct {
	Uid         uint64              `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Value       []byte              `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	ValType     Posting_ValType     `protobuf:"varint,3,opt,name=val_type,json=valType,proto3,enum=pb.Posting_ValType" json:"val_type,omitempty"`
	PostingType Posting_PostingType `protobuf:"varint,4,opt,name=posting_type,json=postingType,proto3,enum=pb.Posting_PostingType" json:"posting_type,omitempty"`
	// TODO: op is only used temporarily. See if we can remove it from here.
	Op       uint32 `protobuf:"varint,12,opt,name=op,proto3" json:"op,omitempty"`
	StartTs  uint64 `protobuf:"varint,13,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64 `protobuf:"varint,14,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *Posting) Reset()         { *m = Posting{} }
func (m *Posting) String() string { return proto.CompactTextString(m) }
func (*Posting) ProtoMessage()    {}
func (*Posting) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22}
}
func (m *Posting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Posting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Posting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Posting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Posting.Merge(m, src)
}
func (m *Posting) XXX_Size() int {
	return m.Size()
}
func (m *Posting) XXX_DiscardUnknown() {
	xxx_messageInfo_Posting.DiscardUnknown(m)
}

var xxx_messageInfo_Posting proto.InternalMessageInfo

func (m *Posting) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Posting) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Posting) GetValType() Posting_ValType {
	if m != nil {
		return m.ValType
	}
	return Posting_DEFAULT
}

func (m *Posting) GetPostingType() Posting_PostingType {
	if m != nil {
		return m.PostingType
	}
	return Posting_REF
}

func (m *Posting) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Posting) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Posting) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type PostingList struct {
	Postings []*Posting `protobuf:"bytes,2,rep,name=postings,proto3" json:"postings,omitempty"`
	CommitTs uint64     `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Splits   []uint64   `protobuf:"varint,4,rep,packed,name=splits,proto3" json:"splits,omitempty"`
	Bitmap   []byte     `protobuf:"bytes,5,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
}

func (m *PostingList) Reset()         { *m = PostingList{} }
func (m *PostingList) String() string { return proto.CompactTextString(m) }
func (*PostingList) ProtoMessage()    {}
func (*PostingList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{23}
}
func (m *PostingList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostingList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostingList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostingList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostingList.Merge(m, src)
}
func (m *PostingList) XXX_Size() int {
	return m.Size()
}
func (m *PostingList) XXX_DiscardUnknown() {
	xxx_messageInfo_PostingList.DiscardUnknown(m)
}

var xxx_messageInfo_PostingList proto.InternalMessageInfo

func (m *PostingList) GetPostings() []*Posting {
	if m != nil {
		return m.Postings
	}
	return nil
}

func (m *PostingList) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *PostingList) GetSplits() []uint64 {
	if m != nil {
		return m.Splits
	}
	return nil
}

func (m *PostingList) GetBitmap() []byte {
	if m != nil {
		return m.Bitmap
	}
	return nil
}

type Function struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Args []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{24}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Function) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// Op and Children are internal nodes and Func on leaves.
type FilterTree struct {
	Op       string        `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	Children []*FilterTree `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	Func     *Function     `protobuf:"bytes,3,opt,name=func,proto3" json:"func,omitempty"`
}

func (m *FilterTree) Reset()         { *m = FilterTree{} }
func (m *FilterTree) String() string { return proto.CompactTextString(m) }
func (*FilterTree) ProtoMessage()    {}
func (*FilterTree) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{25}
}
func (m *FilterTree) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterTree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FilterTree.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FilterTree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterTree.Merge(m, src)
}
func (m *FilterTree) XXX_Size() int {
	return m.Size()
}
func (m *FilterTree) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterTree.DiscardUnknown(m)
}

var xxx_messageInfo_FilterTree proto.InternalMessageInfo

func (m *FilterTree) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *FilterTree) GetChildren() []*FilterTree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *FilterTree) GetFunc() *Function {
	if m != nil {
		return m.Func
	}
	return nil
}

// Schema messages.
type SchemaRequest struct {
	GroupId    uint32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Predicates []string `protobuf:"bytes,2,rep,name=predicates,proto3" json:"predicates,omitempty"`
	// Fields can be on of type, index, or tokenizer.
	Fields []string `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields,omitempty"`
	Types  []string `protobuf:"bytes,4,rep,name=types,proto3" json:"types,omitempty"`
}

func (m *SchemaRequest) Reset()         { *m = SchemaRequest{} }
func (m *SchemaRequest) String() string { return proto.CompactTextString(m) }
func (*SchemaRequest) ProtoMessage()    {}
func (*SchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{26}
}
func (m *SchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaRequest.Merge(m, src)
}
func (m *SchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *SchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaRequest proto.InternalMessageInfo

func (m *SchemaRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *SchemaRequest) GetPredicates() []string {
	if m != nil {
		return m.Predicates
	}
	return nil
}

func (m *SchemaRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SchemaRequest) GetTypes() []string {
	if m != nil {
		return m.Types
	}
	return nil
}

type SchemaNode struct {
	Predicate string   `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	Type      string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Index     bool     `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Tokenizer []string `protobuf:"bytes,4,rep,name=tokenizer,proto3" json:"tokenizer,omitempty"`
	Count     bool     `protobuf:"varint,6,opt,name=count,proto3" json:"count,omitempty"`
	List      bool     `protobuf:"varint,7,opt,name=list,proto3" json:"list,omitempty"`
	Upsert    bool     `protobuf:"varint,8,opt,name=upsert,proto3" json:"upsert,omitempty"`
}

func (m *SchemaNode) Reset()         { *m = SchemaNode{} }
func (m *SchemaNode) String() string { return proto.CompactTextString(m) }
func (*SchemaNode) ProtoMessage()    {}
func (*SchemaNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{27}
}
func (m *SchemaNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaNode.Merge(m, src)
}
func (m *SchemaNode) XXX_Size() int {
	return m.Size()
}
func (m *SchemaNode) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaNode.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaNode proto.InternalMessageInfo

func (m *SchemaNode) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *SchemaNode) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SchemaNode) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *SchemaNode) GetTokenizer() []string {
	if m != nil {
		return m.Tokenizer
	}
	return nil
}

func (m *SchemaNode) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SchemaNode) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

func (m *SchemaNode) GetUpsert() bool {
	if m != nil {
		return m.Upsert
	}
	return false
}

type SchemaResult struct {
	Schema []*SchemaNode `protobuf:"bytes,1,rep,name=schema,proto3" json:"schema,omitempty"` // Deprecated: Do not use.
}

func (m *SchemaResult) Reset()         { *m = SchemaResult{} }
func (m *SchemaResult) String() string { return proto.CompactTextString(m) }
func (*SchemaResult) ProtoMessage()    {}
func (*SchemaResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{28}
}
func (m *SchemaResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaResult.Merge(m, src)
}
func (m *SchemaResult) XXX_Size() int {
	return m.Size()
}
func (m *SchemaResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaResult.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaResult proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SchemaResult) GetSchema() []*SchemaNode {
	if m != nil {
		return m.Schema
	}
	return nil
}

type SchemaUpdate struct {
	Predicate string                 `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	ValueType Posting_ValType        `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=pb.Posting_ValType" json:"value_type,omitempty"`
	Directive SchemaUpdate_Directive `protobuf:"varint,3,opt,name=directive,proto3,enum=pb.SchemaUpdate_Directive" json:"directive,omitempty"`
	Tokenizer []string               `protobuf:"bytes,4,rep,name=tokenizer,proto3" json:"tokenizer,omitempty"`
	Count     bool                   `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	List      bool                   `protobuf:"varint,6,opt,name=list,proto3" json:"list,omitempty"`
	Upsert    bool                   `protobuf:"varint,7,opt,name=upsert,proto3" json:"upsert,omitempty"`
}

func (m *SchemaUpdate) Reset()         { *m = SchemaUpdate{} }
func (m *SchemaUpdate) String() string { return proto.CompactTextString(m) }
func (*SchemaUpdate) ProtoMessage()    {}
func (*SchemaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{29}
}
func (m *SchemaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaUpdate.Merge(m, src)
}
func (m *SchemaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SchemaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaUpdate proto.InternalMessageInfo

func (m *SchemaUpdate) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *SchemaUpdate) GetValueType() Posting_ValType {
	if m != nil {
		return m.ValueType
	}
	return Posting_DEFAULT
}

func (m *SchemaUpdate) GetDirective() SchemaUpdate_Directive {
	if m != nil {
		return m.Directive
	}
	return SchemaUpdate_NONE
}

func (m *SchemaUpdate) GetTokenizer() []string {
	if m != nil {
		return m.Tokenizer
	}
	return nil
}

func (m *SchemaUpdate) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SchemaUpdate) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

func (m *SchemaUpdate) GetUpsert() bool {
	if m != nil {
		return m.Upsert
	}
	return false
}

type MapHeader struct {
	PartitionKeys [][]byte `protobuf:"bytes,1,rep,name=partition_keys,json=partitionKeys,proto3" json:"partition_keys,omitempty"`
}

func (m *MapHeader) Reset()         { *m = MapHeader{} }
func (m *MapHeader) String() string { return proto.CompactTextString(m) }
func (*MapHeader) ProtoMessage()    {}
func (*MapHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{30}
}
func (m *MapHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapHeader.Merge(m, src)
}
func (m *MapHeader) XXX_Size() int {
	return m.Size()
}
func (m *MapHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MapHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MapHeader proto.InternalMessageInfo

func (m *MapHeader) GetPartitionKeys() [][]byte {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

type MovePredicatePayload struct {
	Predicate        string `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	SourceGid        uint32 `protobuf:"varint,2,opt,name=source_gid,json=sourceGid,proto3" json:"source_gid,omitempty"`
	DestGid          uint32 `protobuf:"varint,3,opt,name=dest_gid,json=destGid,proto3" json:"dest_gid,omitempty"`
	ReadTs           uint64 `protobuf:"varint,4,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	ExpectedChecksum uint64 `protobuf:"varint,5,opt,name=expected_checksum,json=expectedChecksum,proto3" json:"expected_checksum,omitempty"`
	SinceTs          uint64 `protobuf:"varint,6,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
}

func (m *MovePredicatePayload) Reset()         { *m = MovePredicatePayload{} }
func (m *MovePredicatePayload) String() string { return proto.CompactTextString(m) }
func (*MovePredicatePayload) ProtoMessage()    {}
func (*MovePredicatePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{31}
}
func (m *MovePredicatePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MovePredicatePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MovePredicatePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MovePredicatePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MovePredicatePayload.Merge(m, src)
}
func (m *MovePredicatePayload) XXX_Size() int {
	return m.Size()
}
func (m *MovePredicatePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MovePredicatePayload.DiscardUnknown(m)
}

var xxx_messageInfo_MovePredicatePayload proto.InternalMessageInfo

func (m *MovePredicatePayload) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *MovePredicatePayload) GetSourceGid() uint32 {
	if m != nil {
		return m.SourceGid
	}
	return 0
}

func (m *MovePredicatePayload) GetDestGid() uint32 {
	if m != nil {
		return m.DestGid
	}
	return 0
}

func (m *MovePredicatePayload) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *MovePredicatePayload) GetExpectedChecksum() uint64 {
	if m != nil {
		return m.ExpectedChecksum
	}
	return 0
}

func (m *MovePredicatePayload) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

type PeerResponse struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PeerResponse) Reset()         { *m = PeerResponse{} }
func (m *PeerResponse) String() string { return proto.CompactTextString(m) }
func (*PeerResponse) ProtoMessage()    {}
func (*PeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{32}
}
func (m *PeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerResponse.Merge(m, src)
}
func (m *PeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *PeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PeerResponse proto.InternalMessageInfo

func (m *PeerResponse) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type RaftBatch struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload *Payload     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *RaftBatch) Reset()         { *m = RaftBatch{} }
func (m *RaftBatch) String() string { return proto.CompactTextString(m) }
func (*RaftBatch) ProtoMessage()    {}
func (*RaftBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{33}
}
func (m *RaftBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftBatch.Merge(m, src)
}
func (m *RaftBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftBatch proto.InternalMessageInfo

func (m *RaftBatch) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RaftBatch) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Payload struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{34}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TxnContext struct {
	StartTs  uint64 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64 `protobuf:"varint,2,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Aborted  bool   `protobuf:"varint,3,opt,name=aborted,proto3" json:"aborted,omitempty"`
	Hash     string `protobuf:"bytes,6,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *TxnContext) Reset()         { *m = TxnContext{} }
func (m *TxnContext) String() string { return proto.CompactTextString(m) }
func (*TxnContext) ProtoMessage()    {}
func (*TxnContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{35}
}
func (m *TxnContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnContext.Merge(m, src)
}
func (m *TxnContext) XXX_Size() int {
	return m.Size()
}
func (m *TxnContext) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnContext.DiscardUnknown(m)
}

var xxx_messageInfo_TxnContext proto.InternalMessageInfo

func (m *TxnContext) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnContext) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *TxnContext) GetAborted() bool {
	if m != nil {
		return m.Aborted
	}
	return false
}

func (m *TxnContext) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Request struct {
	StartTs    uint64             `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Query      string             `protobuf:"bytes,4,opt,name=query,proto3" json:"query,omitempty"`
	Vars       map[string]string  `protobuf:"bytes,5,rep,name=vars,proto3" json:"vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReadOnly   bool               `protobuf:"varint,6,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	BestEffort bool               `protobuf:"varint,7,opt,name=best_effort,json=bestEffort,proto3" json:"best_effort,omitempty"`
	Mutations  []*Mutation        `protobuf:"bytes,12,rep,name=mutations,proto3" json:"mutations,omitempty"`
	CommitNow  bool               `protobuf:"varint,13,opt,name=commit_now,json=commitNow,proto3" json:"commit_now,omitempty"`
	RespFormat Request_RespFormat `protobuf:"varint,14,opt,name=resp_format,json=respFormat,proto3,enum=pb.Request_RespFormat" json:"resp_format,omitempty"`
	Hash       string             `protobuf:"bytes,15,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{36}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Request) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *Request) GetVars() map[string]string {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *Request) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Request) GetBestEffort() bool {
	if m != nil {
		return m.BestEffort
	}
	return false
}

func (m *Request) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *Request) GetCommitNow() bool {
	if m != nil {
		return m.CommitNow
	}
	return false
}

func (m *Request) GetRespFormat() Request_RespFormat {
	if m != nil {
		return m.RespFormat
	}
	return Request_JSON
}

func (m *Request) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Uids struct {
	Uids []string `protobuf:"bytes,1,rep,name=uids,proto3" json:"uids,omitempty"`
}

func (m *Uids) Reset()         { *m = Uids{} }
func (m *Uids) String() string { return proto.CompactTextString(m) }
func (*Uids) ProtoMessage()    {}
func (*Uids) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{37}
}
func (m *Uids) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Uids) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Uids.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Uids) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Uids.Merge(m, src)
}
func (m *Uids) XXX_Size() int {
	return m.Size()
}
func (m *Uids) XXX_DiscardUnknown() {
	xxx_messageInfo_Uids.DiscardUnknown(m)
}

var xxx_messageInfo_Uids proto.InternalMessageInfo

func (m *Uids) GetUids() []string {
	if m != nil {
		return m.Uids
	}
	return nil
}

type ListOfString struct {
	Value []string `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *ListOfString) Reset()         { *m = ListOfString{} }
func (m *ListOfString) String() string { return proto.CompactTextString(m) }
func (*ListOfString) ProtoMessage()    {}
func (*ListOfString) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{38}
}
func (m *ListOfString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOfString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOfString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListOfString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOfString.Merge(m, src)
}
func (m *ListOfString) XXX_Size() int {
	return m.Size()
}
func (m *ListOfString) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOfString.DiscardUnknown(m)
}

var xxx_messageInfo_ListOfString proto.InternalMessageInfo

func (m *ListOfString) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

type Response struct {
	Json    []byte      `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
	Txn     *TxnContext `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn,omitempty"`
	Latency *Latency    `protobuf:"bytes,3,opt,name=latency,proto3" json:"latency,omitempty"`
	// Metrics contains all metrics related to the query.
	Metrics *Metrics `protobuf:"bytes,4,opt,name=metrics,proto3" json:"metrics,omitempty"`
	// uids contains a mapping of blank_node => uid for the node. It only returns uids
	// that were created as part of a mutation.
	Uids map[string]string        `protobuf:"bytes,12,rep,name=uids,proto3" json:"uids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Rdf  []byte                   `protobuf:"bytes,13,opt,name=rdf,proto3" json:"rdf,omitempty"`
	Hdrs map[string]*ListOfString `protobuf:"bytes,14,rep,name=hdrs,proto3" json:"hdrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{39}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetJson() []byte {
	if m != nil {
		return m.Json
	}
	return nil
}

func (m *Response) GetTxn() *TxnContext {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *Response) GetLatency() *Latency {
	if m != nil {
		return m.Latency
	}
	return nil
}

func (m *Response) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Response) GetUids() map[string]string {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *Response) GetRdf() []byte {
	if m != nil {
		return m.Rdf
	}
	return nil
}

func (m *Response) GetHdrs() map[string]*ListOfString {
	if m != nil {
		return m.Hdrs
	}
	return nil
}

type Mutation struct {
	SetJson    []byte   `protobuf:"bytes,1,opt,name=set_json,json=setJson,proto3" json:"set_json,omitempty"`
	DeleteJson []byte   `protobuf:"bytes,2,opt,name=delete_json,json=deleteJson,proto3" json:"delete_json,omitempty"`
	SetNquads  []byte   `protobuf:"bytes,3,opt,name=set_nquads,json=setNquads,proto3" json:"set_nquads,omitempty"`
	DelNquads  []byte   `protobuf:"bytes,4,opt,name=del_nquads,json=delNquads,proto3" json:"del_nquads,omitempty"`
	Set        []*NQuad `protobuf:"bytes,5,rep,name=set,proto3" json:"set,omitempty"`
	Del        []*NQuad `protobuf:"bytes,6,rep,name=del,proto3" json:"del,omitempty"`
	// This is being used for upserts.
	Cond string `protobuf:"bytes,9,opt,name=cond,proto3" json:"cond,omitempty"`
	// This field is a duplicate of the one in Request and placed here for convenience.
	CommitNow bool `protobuf:"varint,14,opt,name=commit_now,json=commitNow,proto3" json:"commit_now,omitempty"`
}

func (m *Mutation) Reset()         { *m = Mutation{} }
func (m *Mutation) String() string { return proto.CompactTextString(m) }
func (*Mutation) ProtoMessage()    {}
func (*Mutation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{40}
}
func (m *Mutation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mutation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mutation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutation.Merge(m, src)
}
func (m *Mutation) XXX_Size() int {
	return m.Size()
}
func (m *Mutation) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutation.DiscardUnknown(m)
}

var xxx_messageInfo_Mutation proto.InternalMessageInfo

func (m *Mutation) GetSetJson() []byte {
	if m != nil {
		return m.SetJson
	}
	return nil
}

func (m *Mutation) GetDeleteJson() []byte {
	if m != nil {
		return m.DeleteJson
	}
	return nil
}

func (m *Mutation) GetSetNquads() []byte {
	if m != nil {
		return m.SetNquads
	}
	return nil
}

func (m *Mutation) GetDelNquads() []byte {
	if m != nil {
		return m.DelNquads
	}
	return nil
}

func (m *Mutation) GetSet() []*NQuad {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Mutation) GetDel() []*NQuad {
	if m != nil {
		return m.Del
	}
	return nil
}

func (m *Mutation) GetCond() string {
	if m != nil {
		return m.Cond
	}
	return ""
}

func (m *Mutation) GetCommitNow() bool {
	if m != nil {
		return m.CommitNow
	}
	return false
}

type Operation struct {
	Schema   string           `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	DropAttr string           `protobuf:"bytes,2,opt,name=drop_attr,json=dropAttr,proto3" json:"drop_attr,omitempty"`
	DropAll  bool             `protobuf:"varint,3,opt,name=drop_all,json=dropAll,proto3" json:"drop_all,omitempty"`
	DropOp   Operation_DropOp `protobuf:"varint,4,opt,name=drop_op,json=dropOp,proto3,enum=pb.Operation_DropOp" json:"drop_op,omitempty"`
	// If drop_op is ATTR or TYPE, drop_value holds the name of the predicate or
	// type to delete.
	DropValue string `protobuf:"bytes,5,opt,name=drop_value,json=dropValue,proto3" json:"drop_value,omitempty"`
	// run indexes in background.
	RunInBackground bool `protobuf:"varint,6,opt,name=run_in_background,json=runInBackground,proto3" json:"run_in_background,omitempty"`
}

func (m *Operation) Reset()         { *m = Operation{} }
func (m *Operation) String() string { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()    {}
func (*Operation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{41}
}
func (m *Operation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operation.Merge(m, src)
}
func (m *Operation) XXX_Size() int {
	return m.Size()
}
func (m *Operation) XXX_DiscardUnknown() {
	xxx_messageInfo_Operation.DiscardUnknown(m)
}

var xxx_messageInfo_Operation proto.InternalMessageInfo

func (m *Operation) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Operation) GetDropAttr() string {
	if m != nil {
		return m.DropAttr
	}
	return ""
}

func (m *Operation) GetDropAll() bool {
	if m != nil {
		return m.DropAll
	}
	return false
}

func (m *Operation) GetDropOp() Operation_DropOp {
	if m != nil {
		return m.DropOp
	}
	return Operation_NONE
}

func (m *Operation) GetDropValue() string {
	if m != nil {
		return m.DropValue
	}
	return ""
}

func (m *Operation) GetRunInBackground() bool {
	if m != nil {
		return m.RunInBackground
	}
	return false
}

type Check struct {
}

func (m *Check) Reset()         { *m = Check{} }
func (m *Check) String() string { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()    {}
func (*Check) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{42}
}
func (m *Check) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Check) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Check.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Check) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Check.Merge(m, src)
}
func (m *Check) XXX_Size() int {
	return m.Size()
}
func (m *Check) XXX_DiscardUnknown() {
	xxx_messageInfo_Check.DiscardUnknown(m)
}

var xxx_messageInfo_Check proto.InternalMessageInfo

type Version struct {
	Tag string `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{43}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

type Latency struct {
	ParsingNs         uint64 `protobuf:"varint,1,opt,name=parsing_ns,json=parsingNs,proto3" json:"parsing_ns,omitempty"`
	ProcessingNs      uint64 `protobuf:"varint,2,opt,name=processing_ns,json=processingNs,proto3" json:"processing_ns,omitempty"`
	EncodingNs        uint64 `protobuf:"varint,3,opt,name=encoding_ns,json=encodingNs,proto3" json:"encoding_ns,omitempty"`
	AssignTimestampNs uint64 `protobuf:"varint,4,opt,name=assign_timestamp_ns,json=assignTimestampNs,proto3" json:"assign_timestamp_ns,omitempty"`
	TotalNs           uint64 `protobuf:"varint,5,opt,name=total_ns,json=totalNs,proto3" json:"total_ns,omitempty"`
}

func (m *Latency) Reset()         { *m = Latency{} }
func (m *Latency) String() string { return proto.CompactTextString(m) }
func (*Latency) ProtoMessage()    {}
func (*Latency) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{44}
}
func (m *Latency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Latency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Latency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Latency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Latency.Merge(m, src)
}
func (m *Latency) XXX_Size() int {
	return m.Size()
}
func (m *Latency) XXX_DiscardUnknown() {
	xxx_messageInfo_Latency.DiscardUnknown(m)
}

var xxx_messageInfo_Latency proto.InternalMessageInfo

func (m *Latency) GetParsingNs() uint64 {
	if m != nil {
		return m.ParsingNs
	}
	return 0
}

func (m *Latency) GetProcessingNs() uint64 {
	if m != nil {
		return m.ProcessingNs
	}
	return 0
}

func (m *Latency) GetEncodingNs() uint64 {
	if m != nil {
		return m.EncodingNs
	}
	return 0
}

func (m *Latency) GetAssignTimestampNs() uint64 {
	if m != nil {
		return m.AssignTimestampNs
	}
	return 0
}

func (m *Latency) GetTotalNs() uint64 {
	if m != nil {
		return m.TotalNs
	}
	return 0
}

type Metrics struct {
	// num_uids is the map of number of uids processed by each attribute.
	NumUids map[string]uint64 `protobuf:"bytes,1,rep,name=num_uids,json=numUids,proto3" json:"num_uids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{45}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetNumUids() map[string]uint64 {
	if m != nil {
		return m.NumUids
	}
	return nil
}

type NQuad struct {
	Subject     string `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	Predicate   string `protobuf:"bytes,2,opt,name=predicate,proto3" json:"predicate,omitempty"`
	ObjectId    string `protobuf:"bytes,3,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	ObjectValue *Value `protobuf:"bytes,4,opt,name=object_value,json=objectValue,proto3" json:"object_value,omitempty"`
	Namespace   uint64 `protobuf:"varint,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Lang        string `protobuf:"bytes,6,opt,name=lang,proto3" json:"lang,omitempty"`
}

func (m *NQuad) Reset()         { *m = NQuad{} }
func (m *NQuad) String() string { return proto.CompactTextString(m) }
func (*NQuad) ProtoMessage()    {}
func (*NQuad) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{46}
}
func (m *NQuad) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NQuad) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NQuad.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NQuad) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NQuad.Merge(m, src)
}
func (m *NQuad) XXX_Size() int {
	return m.Size()
}
func (m *NQuad) XXX_DiscardUnknown() {
	xxx_messageInfo_NQuad.DiscardUnknown(m)
}

var xxx_messageInfo_NQuad proto.InternalMessageInfo

func (m *NQuad) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *NQuad) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *NQuad) GetObjectId() string {
	if m != nil {
		return m.ObjectId
	}
	return ""
}

func (m *NQuad) GetObjectValue() *Value {
	if m != nil {
		return m.ObjectValue
	}
	return nil
}

func (m *NQuad) GetNamespace() uint64 {
	if m != nil {
		return m.Namespace
	}
	return 0
}

func (m *NQuad) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

type Value struct {
	// Types that are valid to be assigned to Val:
	//	*Value_DefaultVal
	//	*Value_BytesVal
	//	*Value_IntVal
	//	*Value_BoolVal
	//	*Value_StrVal
	//	*Value_DoubleVal
	//	*Value_GeoVal
	//	*Value_DateVal
	//	*Value_DatetimeVal
	//	*Value_PasswordVal
	//	*Value_UidVal
	Val isValue_Val `protobuf_oneof:"val"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{47}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Val interface {
	isValue_Val()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_DefaultVal struct {
	DefaultVal string `protobuf:"bytes,1,opt,name=default_val,json=defaultVal,proto3,oneof" json:"default_val,omitempty"`
}
type Value_BytesVal struct {
	BytesVal []byte `protobuf:"bytes,2,opt,name=bytes_val,json=bytesVal,proto3,oneof" json:"bytes_val,omitempty"`
}
type Value_IntVal struct {
	IntVal int64 `protobuf:"varint,3,opt,name=int_val,json=intVal,proto3,oneof" json:"int_val,omitempty"`
}
type Value_BoolVal struct {
	BoolVal bool `protobuf:"varint,4,opt,name=bool_val,json=boolVal,proto3,oneof" json:"bool_val,omitempty"`
}
type Value_StrVal struct {
	StrVal string `protobuf:"bytes,5,opt,name=str_val,json=strVal,proto3,oneof" json:"str_val,omitempty"`
}
type Value_DoubleVal struct {
	DoubleVal float64 `protobuf:"fixed64,6,opt,name=double_val,json=doubleVal,proto3,oneof" json:"double_val,omitempty"`
}
type Value_GeoVal struct {
	GeoVal []byte `protobuf:"bytes,7,opt,name=geo_val,json=geoVal,proto3,oneof" json:"geo_val,omitempty"`
}
type Value_DateVal struct {
	DateVal []byte `protobuf:"bytes,8,opt,name=date_val,json=dateVal,proto3,oneof" json:"date_val,omitempty"`
}
type Value_DatetimeVal struct {
	DatetimeVal []byte `protobuf:"bytes,9,opt,name=datetime_val,json=datetimeVal,proto3,oneof" json:"datetime_val,omitempty"`
}
type Value_PasswordVal struct {
	PasswordVal string `protobuf:"bytes,10,opt,name=password_val,json=passwordVal,proto3,oneof" json:"password_val,omitempty"`
}
type Value_UidVal struct {
	UidVal uint64 `protobuf:"varint,11,opt,name=uid_val,json=uidVal,proto3,oneof" json:"uid_val,omitempty"`
}

func (*Value_DefaultVal) isValue_Val()  {}
func (*Value_BytesVal) isValue_Val()    {}
func (*Value_IntVal) isValue_Val()      {}
func (*Value_BoolVal) isValue_Val()     {}
func (*Value_StrVal) isValue_Val()      {}
func (*Value_DoubleVal) isValue_Val()   {}
func (*Value_GeoVal) isValue_Val()      {}
func (*Value_DateVal) isValue_Val()     {}
func (*Value_DatetimeVal) isValue_Val() {}
func (*Value_PasswordVal) isValue_Val() {}
func (*Value_UidVal) isValue_Val()      {}

func (m *Value) GetVal() isValue_Val {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Value) GetDefaultVal() string {
	if x, ok := m.GetVal().(*Value_DefaultVal); ok {
		return x.DefaultVal
	}
	return ""
}

func (m *Value) GetBytesVal() []byte {
	if x, ok := m.GetVal().(*Value_BytesVal); ok {
		return x.BytesVal
	}
	return nil
}

func (m *Value) GetIntVal() int64 {
	if x, ok := m.GetVal().(*Value_IntVal); ok {
		return x.IntVal
	}
	return 0
}

func (m *Value) GetBoolVal() bool {
	if x, ok := m.GetVal().(*Value_BoolVal); ok {
		return x.BoolVal
	}
	return false
}

func (m *Value) GetStrVal() string {
	if x, ok := m.GetVal().(*Value_StrVal); ok {
		return x.StrVal
	}
	return ""
}

func (m *Value) GetDoubleVal() float64 {
	if x, ok := m.GetVal().(*Value_DoubleVal); ok {
		return x.DoubleVal
	}
	return 0
}

func (m *Value) GetGeoVal() []byte {
	if x, ok := m.GetVal().(*Value_GeoVal); ok {
		return x.GeoVal
	}
	return nil
}

func (m *Value) GetDateVal() []byte {
	if x, ok := m.GetVal().(*Value_DateVal); ok {
		return x.DateVal
	}
	return nil
}

func (m *Value) GetDatetimeVal() []byte {
	if x, ok := m.GetVal().(*Value_DatetimeVal); ok {
		return x.DatetimeVal
	}
	return nil
}

func (m *Value) GetPasswordVal() string {
	if x, ok := m.GetVal().(*Value_PasswordVal); ok {
		return x.PasswordVal
	}
	return ""
}

func (m *Value) GetUidVal() uint64 {
	if x, ok := m.GetVal().(*Value_UidVal); ok {
		return x.UidVal
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_DefaultVal)(nil),
		(*Value_BytesVal)(nil),
		(*Value_IntVal)(nil),
		(*Value_BoolVal)(nil),
		(*Value_StrVal)(nil),
		(*Value_DoubleVal)(nil),
		(*Value_GeoVal)(nil),
		(*Value_DateVal)(nil),
		(*Value_DatetimeVal)(nil),
		(*Value_PasswordVal)(nil),
		(*Value_UidVal)(nil),
	}
}

type LoginRequest struct {
	Userid       string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Password     string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	RefreshToken string `protobuf:"bytes,3,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	Namespace    uint64 `protobuf:"varint,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *LoginRequest) Reset()         { *m = LoginRequest{} }
func (m *LoginRequest) String() string { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()    {}
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{48}
}
func (m *LoginRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginRequest.Merge(m, src)
}
func (m *LoginRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoginRequest proto.InternalMessageInfo

func (m *LoginRequest) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *LoginRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *LoginRequest) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *LoginRequest) GetNamespace() uint64 {
	if m != nil {
		return m.Namespace
	}
	return 0
}

type Jwt struct {
	AccessJwt  string `protobuf:"bytes,1,opt,name=access_jwt,json=accessJwt,proto3" json:"access_jwt,omitempty"`
	RefreshJwt string `protobuf:"bytes,2,opt,name=refresh_jwt,json=refreshJwt,proto3" json:"refresh_jwt,omitempty"`
}

func (m *Jwt) Reset()         { *m = Jwt{} }
func (m *Jwt) String() string { return proto.CompactTextString(m) }
func (*Jwt) ProtoMessage()    {}
func (*Jwt) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{49}
}
func (m *Jwt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Jwt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Jwt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Jwt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Jwt.Merge(m, src)
}
func (m *Jwt) XXX_Size() int {
	return m.Size()
}
func (m *Jwt) XXX_DiscardUnknown() {
	xxx_messageInfo_Jwt.DiscardUnknown(m)
}

var xxx_messageInfo_Jwt proto.InternalMessageInfo

func (m *Jwt) GetAccessJwt() string {
	if m != nil {
		return m.AccessJwt
	}
	return ""
}

func (m *Jwt) GetRefreshJwt() string {
	if m != nil {
		return m.RefreshJwt
	}
	return ""
}

type TabletResponse struct {
	Tablets []*Tablet `protobuf:"bytes,1,rep,name=tablets,proto3" json:"tablets,omitempty"`
}

func (m *TabletResponse) Reset()         { *m = TabletResponse{} }
func (m *TabletResponse) String() string { return proto.CompactTextString(m) }
func (*TabletResponse) ProtoMessage()    {}
func (*TabletResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{50}
}
func (m *TabletResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TabletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TabletResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TabletResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TabletResponse.Merge(m, src)
}
func (m *TabletResponse) XXX_Size() int {
	return m.Size()
}
func (m *TabletResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TabletResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TabletResponse proto.InternalMessageInfo

func (m *TabletResponse) GetTablets() []*Tablet {
	if m != nil {
		return m.Tablets
	}
	return nil
}

type TabletRequest struct {
	Tablets []*Tablet `protobuf:"bytes,1,rep,name=tablets,proto3" json:"tablets,omitempty"`
	GroupId uint32    `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"groupId,omitempty"`
}

func (m *TabletRequest) Reset()         { *m = TabletRequest{} }
func (m *TabletRequest) String() string { return proto.CompactTextString(m) }
func (*TabletRequest) ProtoMessage()    {}
func (*TabletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{51}
}
func (m *TabletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TabletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TabletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TabletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TabletRequest.Merge(m, src)
}
func (m *TabletRequest) XXX_Size() int {
	return m.Size()
}
func (m *TabletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TabletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TabletRequest proto.InternalMessageInfo

func (m *TabletRequest) GetTablets() []*Tablet {
	if m != nil {
		return m.Tablets
	}
	return nil
}

func (m *TabletRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type SubscriptionRequest struct {
	Prefixes [][]byte    `protobuf:"bytes,1,rep,name=prefixes,proto3" json:"prefixes,omitempty"`
	Matches  []*pb.Match `protobuf:"bytes,2,rep,name=matches,proto3" json:"matches,omitempty"`
}

func (m *SubscriptionRequest) Reset()         { *m = SubscriptionRequest{} }
func (m *SubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*SubscriptionRequest) ProtoMessage()    {}
func (*SubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{52}
}
func (m *SubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionRequest.Merge(m, src)
}
func (m *SubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionRequest proto.InternalMessageInfo

func (m *SubscriptionRequest) GetPrefixes() [][]byte {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

func (m *SubscriptionRequest) GetMatches() []*pb.Match {
	if m != nil {
		return m.Matches
	}
	return nil
}

type SubscriptionResponse struct {
	Kvs *pb.KVList `protobuf:"bytes,1,opt,name=kvs,proto3" json:"kvs,omitempty"`
}

func (m *SubscriptionResponse) Reset()         { *m = SubscriptionResponse{} }
func (m *SubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*SubscriptionResponse) ProtoMessage()    {}
func (*SubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{53}
}
func (m *SubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionResponse.Merge(m, src)
}
func (m *SubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionResponse proto.InternalMessageInfo

func (m *SubscriptionResponse) GetKvs() *pb.KVList {
	if m != nil {
		return m.Kvs
	}
	return nil
}

type Num struct {
	Val       uint64 `protobuf:"varint,1,opt,name=val,proto3" json:"val,omitempty"`
	ReadOnly  bool   `protobuf:"varint,2,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Forwarded bool   `protobuf:"varint,3,opt,name=forwarded,proto3" json:"forwarded,omitempty"`
	// If bump is set to true then we bump the lease to val. If false, we assign new ids with count
	// equal to val.
	Bump bool         `protobuf:"varint,5,opt,name=bump,proto3" json:"bump,omitempty"`
	Type NumLeaseType `protobuf:"varint,4,opt,name=type,proto3,enum=pb.NumLeaseType" json:"type,omitempty"`
}

func (m *Num) Reset()         { *m = Num{} }
func (m *Num) String() string { return proto.CompactTextString(m) }
func (*Num) ProtoMessage()    {}
func (*Num) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{54}
}
func (m *Num) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Num) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Num.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Num) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Num.Merge(m, src)
}
func (m *Num) XXX_Size() int {
	return m.Size()
}
func (m *Num) XXX_DiscardUnknown() {
	xxx_messageInfo_Num.DiscardUnknown(m)
}

var xxx_messageInfo_Num proto.InternalMessageInfo

func (m *Num) GetVal() uint64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *Num) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Num) GetForwarded() bool {
	if m != nil {
		return m.Forwarded
	}
	return false
}

func (m *Num) GetBump() bool {
	if m != nil {
		return m.Bump
	}
	return false
}

func (m *Num) GetType() NumLeaseType {
	if m != nil {
		return m.Type
	}
	return Num_NS_ID
}

type AssignedIds struct {
	StartId uint64 `protobuf:"varint,1,opt,name=startId,proto3" json:"startId,omitempty"`
	EndId   uint64 `protobuf:"varint,2,opt,name=endId,proto3" json:"endId,omitempty"`
	// The following is used for read only transactions.
	ReadOnly uint64 `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
}

func (m *AssignedIds) Reset()         { *m = AssignedIds{} }
func (m *AssignedIds) String() string { return proto.CompactTextString(m) }
func (*AssignedIds) ProtoMessage()    {}
func (*AssignedIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{55}
}
func (m *AssignedIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignedIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignedIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignedIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignedIds.Merge(m, src)
}
func (m *AssignedIds) XXX_Size() int {
	return m.Size()
}
func (m *AssignedIds) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignedIds.DiscardUnknown(m)
}

var xxx_messageInfo_AssignedIds proto.InternalMessageInfo

func (m *AssignedIds) GetStartId() uint64 {
	if m != nil {
		return m.StartId
	}
	return 0
}

func (m *AssignedIds) GetEndId() uint64 {
	if m != nil {
		return m.EndId
	}
	return 0
}

func (m *AssignedIds) GetReadOnly() uint64 {
	if m != nil {
		return m.ReadOnly
	}
	return 0
}

type RemoveNodeRequest struct {
	NodeId  uint64 `protobuf:"varint,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	GroupId uint32 `protobuf:"varint,2,opt,name=groupId,proto3" json:"groupId,omitempty"`
}

func (m *RemoveNodeRequest) Reset()         { *m = RemoveNodeRequest{} }
func (m *RemoveNodeRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveNodeRequest) ProtoMessage()    {}
func (*RemoveNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{56}
}
func (m *RemoveNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveNodeRequest.Merge(m, src)
}
func (m *RemoveNodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveNodeRequest proto.InternalMessageInfo

func (m *RemoveNodeRequest) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *RemoveNodeRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type MoveTabletRequest struct {
	Namespace uint64 `protobuf:"varint,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Tablet    string `protobuf:"bytes,2,opt,name=tablet,proto3" json:"tablet,omitempty"`
	DstGroup  uint32 `protobuf:"varint,3,opt,name=dstGroup,proto3" json:"dstGroup,omitempty"`
}

func (m *MoveTabletRequest) Reset()         { *m = MoveTabletRequest{} }
func (m *MoveTabletRequest) String() string { return proto.CompactTextString(m) }
func (*MoveTabletRequest) ProtoMessage()    {}
func (*MoveTabletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{57}
}
func (m *MoveTabletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveTabletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveTabletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveTabletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveTabletRequest.Merge(m, src)
}
func (m *MoveTabletRequest) XXX_Size() int {
	return m.Size()
}
func (m *MoveTabletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveTabletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MoveTabletRequest proto.InternalMessageInfo

func (m *MoveTabletRequest) GetNamespace() uint64 {
	if m != nil {
		return m.Namespace
	}
	return 0
}

func (m *MoveTabletRequest) GetTablet() string {
	if m != nil {
		return m.Tablet
	}
	return ""
}

func (m *MoveTabletRequest) GetDstGroup() uint32 {
	if m != nil {
		return m.DstGroup
	}
	return 0
}

type SnapshotMeta struct {
	ClientTs uint64 `protobuf:"varint,1,opt,name=client_ts,json=clientTs,proto3" json:"client_ts,omitempty"`
	GroupId  uint32 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
}

func (m *SnapshotMeta) Reset()         { *m = SnapshotMeta{} }
func (m *SnapshotMeta) String() string { return proto.CompactTextString(m) }
func (*SnapshotMeta) ProtoMessage()    {}
func (*SnapshotMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{58}
}
func (m *SnapshotMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotMeta.Merge(m, src)
}
func (m *SnapshotMeta) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotMeta proto.InternalMessageInfo

func (m *SnapshotMeta) GetClientTs() uint64 {
	if m != nil {
		return m.ClientTs
	}
	return 0
}

func (m *SnapshotMeta) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

// Status describes a general status response.
// code: 0 = success, 0 != failure.
type Status struct {
	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{59}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type ExportRequest struct {
	GroupId     uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	ReadTs      uint64 `protobuf:"varint,2,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	UnixTs      int64  `protobuf:"varint,3,opt,name=unix_ts,json=unixTs,proto3" json:"unix_ts,omitempty"`
	Format      string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	Destination string `protobuf:"bytes,5,opt,name=destination,proto3" json:"destination,omitempty"`
	// These credentials are used to access the S3 or minio bucket.
	AccessKey    string `protobuf:"bytes,6,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretKey    string `protobuf:"bytes,7,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	SessionToken string `protobuf:"bytes,8,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	Anonymous    bool   `protobuf:"varint,9,opt,name=anonymous,proto3" json:"anonymous,omitempty"`
	Namespace    uint64 `protobuf:"varint,10,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ExportRequest) Reset()         { *m = ExportRequest{} }
func (m *ExportRequest) String() string { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()    {}
func (*ExportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{60}
}
func (m *ExportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportRequest.Merge(m, src)
}
func (m *ExportRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportRequest proto.InternalMessageInfo

func (m *ExportRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ExportRequest) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *ExportRequest) GetUnixTs() int64 {
	if m != nil {
		return m.UnixTs
	}
	return 0
}

func (m *ExportRequest) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *ExportRequest) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ExportRequest) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *ExportRequest) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

func (m *ExportRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *ExportRequest) GetAnonymous() bool {
	if m != nil {
		return m.Anonymous
	}
	return false
}

func (m *ExportRequest) GetNamespace() uint64 {
	if m != nil {
		return m.Namespace
	}
	return 0
}

type ExportResponse struct {
	// 0 indicates a success, and a non-zero code indicates failure
	Code  int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg   string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Files []string `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *ExportResponse) Reset()         { *m = ExportResponse{} }
func (m *ExportResponse) String() string { return proto.CompactTextString(m) }
func (*ExportResponse) ProtoMessage()    {}
func (*ExportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{61}
}
func (m *ExportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportResponse.Merge(m, src)
}
func (m *ExportResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportResponse proto.InternalMessageInfo

func (m *ExportResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ExportResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ExportResponse) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

type UpdateGraphQLSchemaRequest struct {
	StartTs       uint64                        `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	GraphqlSchema string                        `protobuf:"bytes,2,opt,name=graphql_schema,json=graphqlSchema,proto3" json:"graphql_schema,omitempty"`
	DgraphPreds   []*SchemaUpdate               `protobuf:"bytes,3,rep,name=dgraph_preds,json=dgraphPreds,proto3" json:"dgraph_preds,omitempty"`
	LambdaScript  string                        `protobuf:"bytes,5,opt,name=lambda_script,json=lambdaScript,proto3" json:"lambda_script,omitempty"`
	Op            UpdateGraphQLSchemaRequest_Op `protobuf:"varint,6,opt,name=op,proto3,enum=pb.UpdateGraphQLSchemaRequest_Op" json:"op,omitempty"`
}

func (m *UpdateGraphQLSchemaRequest) Reset()         { *m = UpdateGraphQLSchemaRequest{} }
func (m *UpdateGraphQLSchemaRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateGraphQLSchemaRequest) ProtoMessage()    {}
func (*UpdateGraphQLSchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{62}
}
func (m *UpdateGraphQLSchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGraphQLSchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGraphQLSchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGraphQLSchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGraphQLSchemaRequest.Merge(m, src)
}
func (m *UpdateGraphQLSchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGraphQLSchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGraphQLSchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGraphQLSchemaRequest proto.InternalMessageInfo

func (m *UpdateGraphQLSchemaRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *UpdateGraphQLSchemaRequest) GetGraphqlSchema() string {
	if m != nil {
		return m.GraphqlSchema
	}
	return ""
}

func (m *UpdateGraphQLSchemaRequest) GetDgraphPreds() []*SchemaUpdate {
	if m != nil {
		return m.DgraphPreds
	}
	return nil
}

func (m *UpdateGraphQLSchemaRequest) GetLambdaScript() string {
	if m != nil {
		return m.LambdaScript
	}
	return ""
}

func (m *UpdateGraphQLSchemaRequest) GetOp() UpdateGraphQLSchemaRequest_Op {
	if m != nil {
		return m.Op
	}
	return UpdateGraphQLSchemaRequest_SCHEMA
}

type UpdateGraphQLSchemaResponse struct {
	Uid uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *UpdateGraphQLSchemaResponse) Reset()         { *m = UpdateGraphQLSchemaResponse{} }
func (m *UpdateGraphQLSchemaResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateGraphQLSchemaResponse) ProtoMessage()    {}
func (*UpdateGraphQLSchemaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{63}
}
func (m *UpdateGraphQLSchemaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGraphQLSchemaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGraphQLSchemaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGraphQLSchemaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGraphQLSchemaResponse.Merge(m, src)
}
func (m *UpdateGraphQLSchemaResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGraphQLSchemaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGraphQLSchemaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGraphQLSchemaResponse proto.InternalMessageInfo

func (m *UpdateGraphQLSchemaResponse) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// BulkMeta stores metadata from the map phase of the bulk loader.
type BulkMeta struct {
	EdgeCount int64                    `protobuf:"varint,1,opt,name=edge_count,json=edgeCount,proto3" json:"edge_count,omitempty"`
	SchemaMap map[string]*SchemaUpdate `protobuf:"bytes,2,rep,name=schema_map,json=schemaMap,proto3" json:"schema_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BulkMeta) Reset()         { *m = BulkMeta{} }
func (m *BulkMeta) String() string { return proto.CompactTextString(m) }
func (*BulkMeta) ProtoMessage()    {}
func (*BulkMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{64}
}
func (m *BulkMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BulkMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BulkMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkMeta.Merge(m, src)
}
func (m *BulkMeta) XXX_Size() int {
	return m.Size()
}
func (m *BulkMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BulkMeta proto.InternalMessageInfo

func (m *BulkMeta) GetEdgeCount() int64 {
	if m != nil {
		return m.EdgeCount
	}
	return 0
}

func (m *BulkMeta) GetSchemaMap() map[string]*SchemaUpdate {
	if m != nil {
		return m.SchemaMap
	}
	return nil
}

type DeleteNsRequest struct {
	GroupId   uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Namespace uint64 `protobuf:"varint,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *DeleteNsRequest) Reset()         { *m = DeleteNsRequest{} }
func (m *DeleteNsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteNsRequest) ProtoMessage()    {}
func (*DeleteNsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{65}
}
func (m *DeleteNsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteNsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteNsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteNsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteNsRequest.Merge(m, src)
}
func (m *DeleteNsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteNsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteNsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteNsRequest proto.InternalMessageInfo

func (m *DeleteNsRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *DeleteNsRequest) GetNamespace() uint64 {
	if m != nil {
		return m.Namespace
	}
	return 0
}

type TaskStatusRequest struct {
	TaskId uint64 `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
}

func (m *TaskStatusRequest) Reset()         { *m = TaskStatusRequest{} }
func (m *TaskStatusRequest) String() string { return proto.CompactTextString(m) }
func (*TaskStatusRequest) ProtoMessage()    {}
func (*TaskStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{66}
}
func (m *TaskStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskStatusRequest.Merge(m, src)
}
func (m *TaskStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *TaskStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TaskStatusRequest proto.InternalMessageInfo

func (m *TaskStatusRequest) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

type TaskStatusResponse struct {
	TaskMeta uint64 `protobuf:"varint,1,opt,name=task_meta,json=taskMeta,proto3" json:"task_meta,omitempty"`
}

func (m *TaskStatusResponse) Reset()         { *m = TaskStatusResponse{} }
func (m *TaskStatusResponse) String() string { return proto.CompactTextString(m) }
func (*TaskStatusResponse) ProtoMessage()    {}
func (*TaskStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{67}
}
func (m *TaskStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskStatusResponse.Merge(m, src)
}
func (m *TaskStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *TaskStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TaskStatusResponse proto.InternalMessageInfo

func (m *TaskStatusResponse) GetTaskMeta() uint64 {
	if m != nil {
		return m.TaskMeta
	}
	return 0
}

func init() {
	proto.RegisterEnum("pb.DirectedEdge_Op", DirectedEdge_Op_name, DirectedEdge_Op_value)
	proto.RegisterEnum("pb.Mutations_DropOp", Mutations_DropOp_name, Mutations_DropOp_value)
	proto.RegisterEnum("pb.Posting_ValType", Posting_ValType_name, Posting_ValType_value)
	proto.RegisterEnum("pb.Posting_PostingType", Posting_PostingType_name, Posting_PostingType_value)
	proto.RegisterEnum("pb.SchemaUpdate_Directive", SchemaUpdate_Directive_name, SchemaUpdate_Directive_value)
	proto.RegisterEnum("pb.Request_RespFormat", Request_RespFormat_name, Request_RespFormat_value)
	proto.RegisterEnum("pb.Operation_DropOp", Operation_DropOp_name, Operation_DropOp_value)
	proto.RegisterEnum("pb.NumLeaseType", NumLeaseType_name, NumLeaseType_value)
	proto.RegisterEnum("pb.UpdateGraphQLSchemaRequest_Op", UpdateGraphQLSchemaRequest_Op_name, UpdateGraphQLSchemaRequest_Op_value)
	proto.RegisterType((*List)(nil), "pb.List")
	proto.RegisterType((*TaskValue)(nil), "pb.TaskValue")
	proto.RegisterType((*SrcFunction)(nil), "pb.SrcFunction")
	proto.RegisterType((*Query)(nil), "pb.Query")
	proto.RegisterType((*ValueList)(nil), "pb.ValueList")
	proto.RegisterType((*Result)(nil), "pb.Result")
	proto.RegisterType((*Order)(nil), "pb.Order")
	proto.RegisterType((*SortMessage)(nil), "pb.SortMessage")
	proto.RegisterType((*SortResult)(nil), "pb.SortResult")
	proto.RegisterType((*RaftContext)(nil), "pb.RaftContext")
	proto.RegisterType((*Member)(nil), "pb.Member")
	proto.RegisterType((*ZeroProposal)(nil), "pb.ZeroProposal")
	proto.RegisterMapType((map[uint32]uint64)(nil), "pb.ZeroProposal.SnapshotTsEntry")
	proto.RegisterType((*MembershipState)(nil), "pb.MembershipState")
	proto.RegisterMapType((map[uint64]*Member)(nil), "pb.MembershipState.MembersEntry")
	proto.RegisterMapType((map[string]*Tablet)(nil), "pb.MembershipState.TabletsEntry")
	proto.RegisterType((*HealthInfo)(nil), "pb.HealthInfo")
	proto.RegisterType((*Tablet)(nil), "pb.Tablet")
	proto.RegisterType((*DirectedEdge)(nil), "pb.DirectedEdge")
	proto.RegisterType((*Mutations)(nil), "pb.Mutations")
	proto.RegisterType((*Snapshot)(nil), "pb.Snapshot")
	proto.RegisterType((*ZeroSnapshot)(nil), "pb.ZeroSnapshot")
	proto.RegisterType((*Proposal)(nil), "pb.Proposal")
	proto.RegisterType((*CDCState)(nil), "pb.CDCState")
	proto.RegisterType((*KVS)(nil), "pb.KVS")
	proto.RegisterType((*Posting)(nil), "pb.Posting")
	proto.RegisterType((*PostingList)(nil), "pb.PostingList")
	proto.RegisterType((*Function)(nil), "pb.Function")
	proto.RegisterType((*FilterTree)(nil), "pb.FilterTree")
	proto.RegisterType((*SchemaRequest)(nil), "pb.SchemaRequest")
	proto.RegisterType((*SchemaNode)(nil), "pb.SchemaNode")
	proto.RegisterType((*SchemaResult)(nil), "pb.SchemaResult")
	proto.RegisterType((*SchemaUpdate)(nil), "pb.SchemaUpdate")
	proto.RegisterType((*MapHeader)(nil), "pb.MapHeader")
	proto.RegisterType((*MovePredicatePayload)(nil), "pb.MovePredicatePayload")
	proto.RegisterType((*PeerResponse)(nil), "pb.PeerResponse")
	proto.RegisterType((*RaftBatch)(nil), "pb.RaftBatch")
	proto.RegisterType((*Payload)(nil), "pb.Payload")
	proto.RegisterType((*TxnContext)(nil), "pb.TxnContext")
	proto.RegisterType((*Request)(nil), "pb.Request")
	proto.RegisterMapType((map[string]string)(nil), "pb.Request.VarsEntry")
	proto.RegisterType((*Uids)(nil), "pb.Uids")
	proto.RegisterType((*ListOfString)(nil), "pb.ListOfString")
	proto.RegisterType((*Response)(nil), "pb.Response")
	proto.RegisterMapType((map[string]*ListOfString)(nil), "pb.Response.HdrsEntry")
	proto.RegisterMapType((map[string]string)(nil), "pb.Response.UidsEntry")
	proto.RegisterType((*Mutation)(nil), "pb.Mutation")
	proto.RegisterType((*Operation)(nil), "pb.Operation")
	proto.RegisterType((*Check)(nil), "pb.Check")
	proto.RegisterType((*Version)(nil), "pb.Version")
	proto.RegisterType((*Latency)(nil), "pb.Latency")
	proto.RegisterType((*Metrics)(nil), "pb.Metrics")
	proto.RegisterMapType((map[string]uint64)(nil), "pb.Metrics.NumUidsEntry")
	proto.RegisterType((*NQuad)(nil), "pb.NQuad")
	proto.RegisterType((*Value)(nil), "pb.Value")
	proto.RegisterType((*LoginRequest)(nil), "pb.LoginRequest")
	proto.RegisterType((*Jwt)(nil), "pb.Jwt")
	proto.RegisterType((*TabletResponse)(nil), "pb.TabletResponse")
	proto.RegisterType((*TabletRequest)(nil), "pb.TabletRequest")
	proto.RegisterType((*SubscriptionRequest)(nil), "pb.SubscriptionRequest")
	proto.RegisterType((*SubscriptionResponse)(nil), "pb.SubscriptionResponse")
	proto.RegisterType((*Num)(nil), "pb.Num")
	proto.RegisterType((*AssignedIds)(nil), "pb.AssignedIds")
	proto.RegisterType((*RemoveNodeRequest)(nil), "pb.RemoveNodeRequest")
	proto.RegisterType((*MoveTabletRequest)(nil), "pb.MoveTabletRequest")
	proto.RegisterType((*SnapshotMeta)(nil), "pb.SnapshotMeta")
	proto.RegisterType((*Status)(nil), "pb.Status")
	proto.RegisterType((*ExportRequest)(nil), "pb.ExportRequest")
	proto.RegisterType((*ExportResponse)(nil), "pb.ExportResponse")
	proto.RegisterType((*UpdateGraphQLSchemaRequest)(nil), "pb.UpdateGraphQLSchemaRequest")
	proto.RegisterType((*UpdateGraphQLSchemaResponse)(nil), "pb.UpdateGraphQLSchemaResponse")
	proto.RegisterType((*BulkMeta)(nil), "pb.BulkMeta")
	proto.RegisterMapType((map[string]*SchemaUpdate)(nil), "pb.BulkMeta.SchemaMapEntry")
	proto.RegisterType((*DeleteNsRequest)(nil), "pb.DeleteNsRequest")
	proto.RegisterType((*TaskStatusRequest)(nil), "pb.TaskStatusRequest")
	proto.RegisterType((*TaskStatusResponse)(nil), "pb.TaskStatusResponse")
}

func init() { proto.RegisterFile("pb.proto", fileDescriptor_f80abaa17e25ccc8) }

var fileDescriptor_f80abaa17e25ccc8 = []byte{
	// 4785 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x7a, 0xdd, 0x6f, 0xdc, 0x56,
	0x76, 0xb8, 0x38, 0x9f, 0xe4, 0x99, 0x19, 0x79, 0xc4, 0x38, 0xce, 0xac, 0x1c, 0x5b, 0x0a, 0x1d,
	0x27, 0xb2, 0x63, 0xcb, 0x89, 0xfd, 0xfb, 0x75, 0x53, 0x2f, 0xb6, 0x80, 0x64, 0xc9, 0xf1, 0x38,
	0xd2, 0xc8, 0xe1, 0x8c, 0xbd, 0xdb, 0x05, 0x16, 0x03, 0x0e, 0x79, 0x35, 0x62, 0xc4, 0x21, 0x19,
	0xde, 0x4b, 0x59, 0xca, 0x7b, 0x17, 0x58, 0x14, 0x05, 0x5a, 0x14, 0xed, 0xe3, 0xa2, 0x7f, 0x43,
	0xd1, 0x2d, 0xd0, 0xa2, 0x7d, 0xe8, 0x5b, 0xdf, 0xba, 0x4f, 0x45, 0x9f, 0x82, 0x36, 0x79, 0x6a,
	0x80, 0x3e, 0xf4, 0xb5, 0xe8, 0x43, 0x71, 0xce, 0xbd, 0xe4, 0x90, 0x63, 0xf9, 0x23, 0x4f, 0xbc,
	0xe7, 0x9c, 0xfb, 0x79, 0xce, 0xb9, 0xe7, 0xeb, 0x12, 0xf4, 0x78, 0xb2, 0x19, 0x27, 0x91, 0x88,
	0xcc, 0x4a, 0x3c, 0x59, 0xbd, 0x35, 0xf5, 0xc5, 0x51, 0x3a, 0xd9, 0x74, 0xa3, 0xd9, 0x9d, 0x28,
	0x15, 0xae, 0xc3, 0x05, 0xbb, 0xed, 0x47, 0x77, 0x26, 0x8e, 0x37, 0x65, 0xc9, 0x9d, 0x93, 0x7b,
	0x77, 0xe2, 0xc9, 0x9d, 0x6c, 0xc4, 0xea, 0xed, 0x42, 0xef, 0x69, 0x34, 0x8d, 0xee, 0x10, 0x7a,
	0x92, 0x1e, 0x12, 0x44, 0x00, 0xb5, 0x64, 0x77, 0xeb, 0x0f, 0xa0, 0xb6, 0xe7, 0x73, 0x61, 0x5e,
	0x82, 0xc6, 0xc4, 0x17, 0x33, 0x27, 0xee, 0x55, 0xd6, 0xb5, 0x8d, 0xb6, 0xad, 0x20, 0xf3, 0x2a,
	0x00, 0x8f, 0x12, 0xc1, 0xbc, 0xa7, 0xbe, 0xc7, 0x7b, 0xd5, 0xf5, 0xea, 0x46, 0xc3, 0x2e, 0x60,
	0xac, 0x7d, 0x30, 0x46, 0x0e, 0x3f, 0x7e, 0xe6, 0x04, 0x29, 0x33, 0xbb, 0x50, 0x3d, 0x71, 0x82,
	0x9e, 0x46, 0x33, 0x60, 0xd3, 0xdc, 0x04, 0xfd, 0xc4, 0x09, 0xc6, 0xe2, 0x2c, 0x66, 0x34, 0xf1,
	0xf2, 0xdd, 0xb7, 0x36, 0xe3, 0xc9, 0xe6, 0x93, 0x88, 0x0b, 0x3f, 0x9c, 0x6e, 0x3e, 0x73, 0x82,
	0xd1, 0x59, 0xcc, 0xec, 0xe6, 0x89, 0x6c, 0x58, 0x07, 0xd0, 0x1a, 0x26, 0xee, 0xc3, 0x34, 0x74,
	0x85, 0x1f, 0x85, 0xa6, 0x09, 0xb5, 0xd0, 0x99, 0x31, 0x9a, 0xd1, 0xb0, 0xa9, 0x8d, 0x38, 0x27,
	0x99, 0xca, 0xbd, 0x18, 0x36, 0xb5, 0xcd, 0x1e, 0x34, 0x7d, 0xfe, 0x20, 0x4a, 0x43, 0xd1, 0xab,
	0xad, 0x6b, 0x1b, 0xba, 0x9d, 0x81, 0xd6, 0x5f, 0x55, 0xa0, 0xfe, 0x45, 0xca, 0x92, 0x33, 0x1a,
	0x27, 0x44, 0x92, 0xcd, 0x85, 0x6d, 0xf3, 0x32, 0x18, 0xce, 0xa1, 0x60, 0xc9, 0x38, 0xf5, 0xbd,
	0x5e, 0x75, 0x5d, 0xdb, 0x68, 0xd8, 0x3a, 0x21, 0x9e, 0xfa, 0x9e, 0xf9, 0x23, 0xd0, 0xbd, 0x68,
	0xec, 0x16, 0x67, 0xf5, 0x22, 0x9a, 0xd5, 0xbc, 0x06, 0x7a, 0xea, 0x7b, 0xe3, 0xc0, 0xe7, 0xa2,
	0x57, 0x5f, 0xd7, 0x36, 0x5a, 0x77, 0x75, 0x3c, 0x16, 0x72, 0xd2, 0x6e, 0xa6, 0xbe, 0x47, 0x2c,
	0xbd, 0x09, 0x3a, 0x4f, 0xdc, 0xf1, 0x61, 0x1a, 0xba, 0xbd, 0x06, 0x75, 0xba, 0x80, 0x9d, 0x0a,
	0xe7, 0xb3, 0x9b, 0x5c, 0x02, 0xe6, 0x15, 0x00, 0x76, 0x1a, 0x3b, 0xa1, 0x37, 0x76, 0x82, 0xa0,
	0x07, 0xb4, 0x9a, 0x21, 0x31, 0x5b, 0x41, 0x60, 0xbe, 0x03, 0xcd, 0x84, 0x39, 0xde, 0x58, 0xf0,
	0x5e, 0x67, 0x5d, 0xdb, 0xa8, 0xd9, 0x0d, 0x04, 0x47, 0xdc, 0xbc, 0x08, 0x75, 0xd7, 0x71, 0x8f,
	0x58, 0x6f, 0x79, 0x5d, 0xdb, 0xa8, 0xdb, 0x12, 0x40, 0xec, 0xa1, 0x9f, 0x70, 0xd1, 0xbb, 0x20,
	0xb1, 0x04, 0xa0, 0x88, 0xa3, 0xc3, 0x43, 0xce, 0x44, 0xaf, 0x4b, 0x68, 0x05, 0x59, 0x77, 0xc1,
	0x20, 0xf1, 0xd1, 0xa6, 0xaf, 0x43, 0xe3, 0x04, 0x01, 0xde, 0xd3, 0xd6, 0xab, 0x1b, 0xad, 0xbb,
	0x1d, 0xdc, 0x72, 0x2e, 0x61, 0x5b, 0x11, 0xad, 0xbf, 0xd5, 0xa0, 0x61, 0x33, 0x9e, 0x06, 0xc2,
	0xfc, 0x10, 0x00, 0x79, 0x31, 0x73, 0x44, 0xe2, 0x9f, 0xaa, 0x51, 0x73, 0x6e, 0x18, 0xa9, 0xef,
	0xed, 0x13, 0xc9, 0xfc, 0x18, 0xda, 0x34, 0x3a, 0xeb, 0x5a, 0x99, 0x2f, 0x90, 0xaf, 0x6f, 0xb7,
	0xa8, 0x8b, 0x1a, 0x71, 0x09, 0x1a, 0xc4, 0x7e, 0x29, 0xec, 0x8e, 0xad, 0x20, 0xf3, 0x3a, 0x2c,
	0xfb, 0xa1, 0x60, 0x09, 0x67, 0xae, 0x18, 0x7b, 0x8c, 0x67, 0xf2, 0xe9, 0xe4, 0xd8, 0x1d, 0xc6,
	0x05, 0x4a, 0x9c, 0x24, 0xd4, 0x24, 0x22, 0xb5, 0xad, 0x3b, 0x50, 0x3f, 0x48, 0x3c, 0x96, 0x9c,
	0xab, 0x0e, 0x26, 0xd4, 0x3c, 0xc6, 0x5d, 0xd2, 0x54, 0xdd, 0xa6, 0xb6, 0xf5, 0x1b, 0x0d, 0x5a,
	0xc3, 0x28, 0x11, 0xfb, 0x8c, 0x73, 0x67, 0xca, 0xcc, 0x35, 0xa8, 0x47, 0x38, 0x81, 0x3a, 0xa9,
	0x81, 0xdb, 0xa7, 0x19, 0x6d, 0x89, 0x5f, 0xe0, 0x47, 0xe5, 0xe5, 0xfc, 0x40, 0xd9, 0x91, 0x72,
	0x55, 0x95, 0xec, 0x48, 0xb5, 0xe6, 0x52, 0xaa, 0x15, 0xa5, 0xf4, 0x52, 0x15, 0xb0, 0xfe, 0x3f,
	0x00, 0xee, 0xef, 0x07, 0x4a, 0x83, 0xce, 0x65, 0x3b, 0x87, 0xe2, 0x41, 0x14, 0x0a, 0x76, 0x2a,
	0xcc, 0xb7, 0xa1, 0xf1, 0xfc, 0x28, 0x1a, 0xfb, 0x5c, 0x71, 0xa4, 0xfe, 0xfc, 0x28, 0xea, 0x73,
	0x73, 0x19, 0x2a, 0xbe, 0x47, 0x0c, 0x69, 0xd8, 0x15, 0xdf, 0xc3, 0x4d, 0x4f, 0x93, 0x28, 0x8d,
	0x69, 0xd3, 0x1d, 0x5b, 0x02, 0xc4, 0x4c, 0xcf, 0x4b, 0x68, 0xcb, 0xc8, 0x4c, 0xcf, 0x4b, 0xcc,
	0x35, 0x68, 0xf1, 0xd0, 0x89, 0xf9, 0x51, 0x24, 0x70, 0xd3, 0x75, 0xda, 0x34, 0x64, 0xa8, 0x11,
	0x47, 0x9d, 0xf7, 0xf9, 0x38, 0x60, 0x4e, 0x12, 0xb2, 0x84, 0x6e, 0x88, 0x6e, 0x1b, 0x3e, 0xdf,
	0x93, 0x08, 0xeb, 0x7f, 0x34, 0x68, 0xec, 0xb3, 0xd9, 0x84, 0x25, 0x6a, 0x13, 0x5a, 0xbe, 0x89,
	0x8f, 0x41, 0xa7, 0x75, 0xc7, 0x6a, 0x6b, 0x9d, 0xed, 0xb7, 0xbf, 0xff, 0x66, 0x6d, 0x85, 0x70,
	0x7d, 0xef, 0x56, 0x34, 0xf3, 0x05, 0x9b, 0xc5, 0xe2, 0xcc, 0x6e, 0x2a, 0x54, 0xbe, 0xc1, 0x6a,
	0x61, 0x83, 0x97, 0xa0, 0x11, 0x30, 0x07, 0x45, 0x29, 0xb5, 0x47, 0x41, 0xe6, 0x6d, 0x68, 0x3a,
	0xb3, 0xb1, 0xc7, 0x1c, 0x8f, 0x36, 0xad, 0x6f, 0x5f, 0xfc, 0xfe, 0x9b, 0xb5, 0xae, 0x33, 0xdb,
	0x61, 0x4e, 0x71, 0xee, 0x86, 0xc4, 0x98, 0xbf, 0x0f, 0xad, 0xc0, 0xe1, 0x62, 0x9c, 0xc6, 0x9e,
	0x23, 0x18, 0x9d, 0xa3, 0xb6, 0xdd, 0xfb, 0xfe, 0x9b, 0xb5, 0x8b, 0x88, 0x7e, 0x4a, 0xd8, 0xc2,
	0x30, 0x98, 0x63, 0xd1, 0x6c, 0x65, 0xc7, 0x97, 0x3a, 0x9a, 0x81, 0xd6, 0x5f, 0x56, 0xa1, 0xfd,
	0x0b, 0x96, 0x44, 0x4f, 0x92, 0x28, 0x8e, 0xb8, 0x13, 0x98, 0x5b, 0x65, 0x6e, 0x4a, 0xc1, 0xae,
	0xa3, 0x60, 0x8b, 0xdd, 0x36, 0x87, 0x39, 0x7b, 0x77, 0x43, 0x91, 0x9c, 0x95, 0xf8, 0x6d, 0x41,
	0x63, 0x46, 0xfc, 0x24, 0x9e, 0xb5, 0xee, 0x02, 0x8e, 0x96, 0x1c, 0xb6, 0x15, 0xc5, 0x7c, 0x1f,
	0x9a, 0xc2, 0x99, 0x04, 0x4c, 0x5d, 0x39, 0xd5, 0x69, 0x44, 0x28, 0x3b, 0x23, 0xa1, 0x65, 0x0c,
	0xd3, 0x19, 0x1a, 0x4d, 0x4e, 0xbc, 0xeb, 0xd8, 0xcd, 0x30, 0x9d, 0xa1, 0x3f, 0x40, 0x8b, 0x8a,
	0xa4, 0x90, 0x23, 0xad, 0x4e, 0x34, 0xec, 0x3b, 0x40, 0x18, 0xfd, 0x83, 0xeb, 0x7b, 0xc4, 0x22,
	0xc3, 0xc6, 0xa6, 0xf9, 0x31, 0x18, 0x1e, 0x0b, 0x98, 0x60, 0xe3, 0x90, 0x13, 0x0f, 0x5a, 0xd2,
	0x41, 0xec, 0x10, 0x72, 0xc0, 0x6d, 0xf6, 0x55, 0xca, 0xb8, 0xb0, 0x75, 0x4f, 0x21, 0x70, 0x01,
	0x37, 0x4e, 0xc7, 0x47, 0x51, 0x9a, 0xf0, 0x9e, 0xbe, 0xae, 0x6d, 0x68, 0xb6, 0xee, 0xc6, 0xe9,
	0x23, 0x84, 0xcd, 0xf7, 0xa0, 0x4d, 0xb2, 0x70, 0x8f, 0x9c, 0x64, 0xca, 0xbc, 0x9e, 0xb1, 0xae,
	0x6d, 0x54, 0x6d, 0x92, 0xcf, 0x03, 0x89, 0x5a, 0xfd, 0x29, 0x5c, 0x58, 0x60, 0x12, 0x6e, 0xeb,
	0x98, 0x9d, 0x91, 0x7e, 0x75, 0x6c, 0x6c, 0xa2, 0x96, 0x93, 0x1d, 0x22, 0x4e, 0xd5, 0x6c, 0x09,
	0xdc, 0xaf, 0x7c, 0xaa, 0x59, 0xff, 0x5a, 0x85, 0x0b, 0x92, 0x67, 0xfc, 0xc8, 0x8f, 0x87, 0x02,
	0xc5, 0x78, 0x1f, 0x9a, 0x92, 0x7d, 0x25, 0xb9, 0x2c, 0xf4, 0xca, 0x60, 0x29, 0x97, 0x6c, 0x00,
	0x8e, 0xcd, 0x18, 0x5e, 0x79, 0xf9, 0x58, 0x29, 0x80, 0x6c, 0x6c, 0x26, 0x86, 0x1e, 0x9a, 0x84,
	0x59, 0x74, 0xc2, 0x3c, 0x12, 0x56, 0xcd, 0xce, 0x40, 0xbc, 0x5a, 0x89, 0x73, 0x28, 0xc6, 0x7e,
	0xe8, 0xb1, 0x53, 0x75, 0xf5, 0x0c, 0xc4, 0xf4, 0x11, 0x81, 0x9a, 0x3f, 0x73, 0x4e, 0x9f, 0xf6,
	0x77, 0xa4, 0xb6, 0xda, 0x0a, 0xc2, 0x09, 0x67, 0xce, 0xe9, 0x80, 0xf7, 0x77, 0x48, 0x16, 0x35,
	0x3b, 0x03, 0x33, 0xc9, 0xe9, 0x73, 0xc9, 0x95, 0xe4, 0x60, 0xbc, 0x46, 0x0e, 0xf0, 0xa2, 0x1c,
	0x1e, 0x42, 0xbb, 0xc8, 0x91, 0xa2, 0x10, 0x6a, 0x52, 0x08, 0xeb, 0x45, 0x21, 0x94, 0xd5, 0x75,
	0x2e, 0x10, 0x9c, 0xa7, 0xc8, 0x9d, 0xe2, 0x3c, 0xc6, 0xcb, 0xe7, 0x51, 0x1a, 0x5d, 0x10, 0xec,
	0x9f, 0x54, 0x00, 0x1e, 0x31, 0x27, 0x10, 0x47, 0xfd, 0xf0, 0x30, 0x32, 0x57, 0x41, 0xf7, 0x43,
	0x2e, 0x9c, 0xd0, 0xcd, 0xa2, 0x8f, 0x1c, 0x46, 0x36, 0xa1, 0x01, 0x61, 0x9c, 0xd3, 0x94, 0x86,
	0x9d, 0x81, 0xc8, 0x58, 0x2e, 0x1c, 0x91, 0x72, 0x65, 0x68, 0x14, 0x34, 0xb7, 0x9a, 0xd2, 0x40,
	0x2a, 0xab, 0xd9, 0x83, 0xe6, 0x09, 0x4b, 0xb8, 0x1f, 0x85, 0x24, 0x22, 0xc3, 0xce, 0x40, 0x9c,
	0x27, 0x8d, 0x85, 0x3f, 0x93, 0xe6, 0xa4, 0x6a, 0x2b, 0x08, 0x77, 0x85, 0x3c, 0xdc, 0x75, 0x8f,
	0x22, 0x92, 0x50, 0xd5, 0xce, 0xe1, 0xa2, 0x83, 0xd0, 0x4b, 0x31, 0x42, 0x0f, 0x9a, 0x51, 0x38,
	0x8d, 0xfc, 0x70, 0xda, 0x33, 0x28, 0x66, 0xca, 0x40, 0x79, 0x48, 0x8f, 0x9d, 0x22, 0x09, 0x88,
	0x94, 0xc3, 0xd6, 0x3f, 0x56, 0xa0, 0x21, 0xb9, 0x54, 0x32, 0xb7, 0xda, 0x1b, 0x99, 0xdb, 0x77,
	0xc1, 0x88, 0x13, 0xe6, 0xf9, 0x2e, 0x5a, 0x44, 0xc9, 0xa3, 0x39, 0x82, 0xc2, 0x93, 0x28, 0x71,
	0x19, 0x31, 0x49, 0xb7, 0x25, 0x60, 0x5a, 0xd0, 0x89, 0xc2, 0xb1, 0xe7, 0xf3, 0xe3, 0xf1, 0xe4,
	0x4c, 0x30, 0xae, 0x0e, 0xd8, 0x8a, 0xc2, 0x1d, 0x9f, 0x1f, 0x6f, 0x23, 0x0a, 0xf9, 0x22, 0x55,
	0x9c, 0x8e, 0xa8, 0xdb, 0x0a, 0x32, 0xef, 0x81, 0x41, 0x67, 0x8f, 0xc2, 0xe0, 0x8c, 0x94, 0x51,
	0xdf, 0xbe, 0xf4, 0xfd, 0x37, 0x6b, 0x26, 0x22, 0x0f, 0xc2, 0xe0, 0xac, 0xb0, 0x47, 0x3d, 0xc3,
	0xa1, 0x9d, 0xc7, 0xc1, 0xc8, 0x30, 0x20, 0xa3, 0x4d, 0x76, 0x1e, 0x51, 0x23, 0x5e, 0xb4, 0xf3,
	0x12, 0x63, 0xde, 0x06, 0x33, 0x0d, 0xdd, 0x68, 0x16, 0xa3, 0xa4, 0x99, 0xa7, 0x36, 0xd9, 0xa2,
	0x4d, 0xae, 0x14, 0x29, 0xb4, 0x55, 0xeb, 0x37, 0x15, 0x68, 0xef, 0xf8, 0x09, 0x73, 0x05, 0xf3,
	0x76, 0xbd, 0x29, 0xc3, 0xbd, 0xb3, 0x50, 0xf8, 0xe2, 0x4c, 0x39, 0x32, 0x05, 0xe5, 0x81, 0x48,
	0xa5, 0x10, 0x88, 0xe4, 0xf6, 0xa7, 0x4a, 0xa1, 0xb4, 0x04, 0xcc, 0xbb, 0x00, 0x32, 0x80, 0xa2,
	0x70, 0xba, 0xf6, 0xf2, 0x70, 0xda, 0xa0, 0x6e, 0xd8, 0x44, 0x53, 0x2d, 0xc7, 0xf8, 0xd2, 0x9b,
	0x35, 0x28, 0xd6, 0x4e, 0x59, 0xdf, 0x33, 0xaf, 0x41, 0x25, 0x8a, 0x89, 0x91, 0x6a, 0x9a, 0xe2,
	0x76, 0x37, 0x0f, 0x62, 0xbb, 0x12, 0xc5, 0xa6, 0x05, 0x6d, 0x27, 0x08, 0xa2, 0xe7, 0xcc, 0x7b,
	0x92, 0x30, 0x8f, 0x2b, 0x35, 0x29, 0xe1, 0x50, 0xda, 0x18, 0x99, 0xf3, 0xd8, 0x71, 0x19, 0x31,
	0xa4, 0x66, 0xcf, 0x11, 0xd6, 0x25, 0xa8, 0x1c, 0xc4, 0x66, 0x13, 0xaa, 0xc3, 0xdd, 0x51, 0x77,
	0x09, 0x1b, 0x3b, 0xbb, 0x7b, 0x5d, 0xcd, 0xfa, 0x2f, 0x0d, 0x8c, 0xfd, 0x54, 0x38, 0x18, 0x08,
	0x93, 0x4b, 0x29, 0xeb, 0xd8, 0x5c, 0x99, 0x3e, 0x80, 0x3a, 0xf3, 0xa6, 0x2c, 0xf3, 0x48, 0xdd,
	0xc5, 0xad, 0xda, 0x92, 0x6c, 0x6e, 0x40, 0x83, 0xbb, 0x47, 0x6c, 0xe6, 0xf4, 0x6a, 0xf3, 0x8e,
	0x43, 0xc2, 0x48, 0x7f, 0x6b, 0x2b, 0x3a, 0x4a, 0xde, 0x4b, 0xa2, 0x78, 0x1c, 0xc5, 0xa4, 0x64,
	0xcb, 0x77, 0x2f, 0x92, 0x6d, 0xc9, 0x36, 0xb3, 0xb9, 0x93, 0x44, 0xf1, 0x41, 0x6c, 0x37, 0x3c,
	0xfa, 0xa2, 0x35, 0xa5, 0xee, 0x52, 0x24, 0xd2, 0x06, 0x1a, 0x88, 0xa1, 0xb0, 0xd5, 0xba, 0x0e,
	0x0d, 0x39, 0xc0, 0xd4, 0xa1, 0x36, 0x38, 0x18, 0xec, 0xca, 0x53, 0x6e, 0xed, 0xed, 0x75, 0x35,
	0x44, 0xed, 0x6c, 0x8d, 0xb6, 0xba, 0x15, 0xeb, 0xcf, 0x35, 0xd0, 0x33, 0xcf, 0x63, 0xde, 0x80,
	0xa6, 0x2b, 0x03, 0x2f, 0x3a, 0xad, 0x4a, 0x0d, 0x0a, 0xf1, 0x98, 0x9d, 0xd1, 0x51, 0x17, 0xa4,
	0x19, 0x57, 0xbe, 0x88, 0x00, 0xbc, 0xed, 0x13, 0x87, 0x93, 0xf2, 0x56, 0xe5, 0x6d, 0x47, 0x70,
	0xc4, 0x29, 0x86, 0x8d, 0x42, 0xa6, 0x62, 0x1a, 0x6a, 0x23, 0x73, 0xb9, 0x1f, 0xba, 0x6c, 0x1e,
	0x87, 0x35, 0x09, 0x1e, 0x71, 0x4b, 0xc8, 0x38, 0x23, 0xdf, 0x58, 0xbe, 0x9a, 0x56, 0x5c, 0xed,
	0x1a, 0x74, 0xdc, 0x23, 0xe6, 0x1e, 0xc7, 0x91, 0x1f, 0x52, 0xfc, 0x21, 0xf7, 0xd2, 0x9e, 0x23,
	0x47, 0xdc, 0xbc, 0x01, 0x75, 0x34, 0x77, 0x4c, 0x65, 0x44, 0x6f, 0x9d, 0xe3, 0xc8, 0x6c, 0xd9,
	0xc3, 0xfa, 0xcf, 0x2a, 0xe8, 0x79, 0x68, 0x73, 0x1d, 0x96, 0xe5, 0x51, 0xfc, 0x19, 0xe3, 0xc2,
	0x99, 0xc5, 0x6a, 0xed, 0x0e, 0x9d, 0x28, 0x43, 0x9a, 0x1f, 0x81, 0x31, 0xcb, 0x24, 0xa4, 0x4c,
	0x79, 0xa7, 0x24, 0x36, 0x7b, 0x4e, 0x37, 0xaf, 0x40, 0xe5, 0xf8, 0x44, 0xe9, 0x41, 0x67, 0x53,
	0x66, 0xca, 0xf1, 0xe4, 0xde, 0xe6, 0xe7, 0xcf, 0xec, 0xca, 0xf1, 0x89, 0xf9, 0x21, 0x5c, 0x70,
	0x03, 0xe6, 0x84, 0xe3, 0xb9, 0x95, 0x92, 0x41, 0xc9, 0x32, 0xa1, 0x9f, 0xe4, 0xa6, 0x6a, 0x03,
	0xf4, 0x2c, 0x82, 0x22, 0xbb, 0xd2, 0xba, 0xdb, 0x26, 0xad, 0x52, 0x38, 0x3b, 0xa7, 0x9a, 0x1f,
	0xc1, 0x0a, 0x3b, 0x8d, 0x49, 0x29, 0xc7, 0xc4, 0x16, 0x9e, 0xce, 0xd4, 0x65, 0xe8, 0x66, 0x84,
	0x07, 0x0a, 0x6f, 0xde, 0x00, 0xc3, 0xf5, 0xdc, 0xb1, 0x64, 0x57, 0x67, 0x3e, 0xef, 0x83, 0x9d,
	0x07, 0x92, 0x4f, 0xba, 0xeb, 0xb9, 0x32, 0xb8, 0x28, 0x45, 0x48, 0xcb, 0x6f, 0x12, 0x21, 0xe5,
	0x22, 0x84, 0xa2, 0x08, 0x95, 0x5f, 0xbc, 0x30, 0xf7, 0xaf, 0x05, 0x87, 0xd1, 0x2d, 0x39, 0x0c,
	0x74, 0xed, 0xd1, 0x6c, 0xe6, 0x93, 0xa4, 0x57, 0x88, 0xa4, 0x4b, 0x84, 0x8c, 0xda, 0x19, 0x3a,
	0xda, 0x31, 0xf7, 0xbf, 0x66, 0x3d, 0x93, 0xcc, 0x9f, 0x41, 0x98, 0xa1, 0xff, 0x35, 0x7b, 0x5c,
	0xd3, 0x9b, 0x5d, 0xfd, 0x71, 0x4d, 0xd7, 0xbb, 0xc6, 0xe3, 0x9a, 0xde, 0xee, 0x76, 0xac, 0x6b,
	0xa0, 0x67, 0xc7, 0xc2, 0x25, 0x39, 0x0b, 0x55, 0x04, 0x4b, 0x4b, 0x22, 0x38, 0xe2, 0xd6, 0x3e,
	0x54, 0x3f, 0x7f, 0x36, 0x24, 0xe5, 0x75, 0x84, 0x43, 0x1a, 0xd4, 0xb6, 0xa9, 0x9d, 0x2b, 0x74,
	0xa5, 0xa0, 0xd0, 0x57, 0x01, 0x72, 0xc9, 0x65, 0x95, 0x80, 0x02, 0xc6, 0xfa, 0xb3, 0x2a, 0x34,
	0x95, 0x51, 0xc4, 0x83, 0xa7, 0x79, 0xf6, 0x80, 0xcd, 0x72, 0x74, 0x97, 0x5b, 0xd7, 0x62, 0xa9,
	0xa2, 0xfa, 0xfa, 0x52, 0x85, 0x79, 0x1f, 0xda, 0xb1, 0xa4, 0x15, 0xed, 0xf1, 0x3b, 0xc5, 0x31,
	0xea, 0x4b, 0xe3, 0x5a, 0xf1, 0x1c, 0xc0, 0x84, 0x26, 0x8a, 0x7b, 0x6d, 0xb2, 0x73, 0x68, 0x65,
	0xf1, 0x82, 0x0a, 0x27, 0x11, 0xf3, 0xec, 0xae, 0x49, 0xf0, 0xa2, 0x30, 0x96, 0xcb, 0xc2, 0xb0,
	0x7e, 0xa5, 0x41, 0x53, 0x6d, 0xcc, 0x6c, 0x41, 0x73, 0x67, 0xf7, 0xe1, 0xd6, 0xd3, 0x3d, 0xb4,
	0xb2, 0x00, 0x8d, 0xed, 0xfe, 0x60, 0xcb, 0xfe, 0xc3, 0xae, 0x86, 0xb6, 0xa8, 0x3f, 0x18, 0x75,
	0x2b, 0xa6, 0x01, 0xf5, 0x87, 0x7b, 0x07, 0x5b, 0xa3, 0x6e, 0x15, 0xcd, 0xd2, 0xf6, 0xc1, 0xc1,
	0x5e, 0xb7, 0x66, 0xb6, 0x41, 0xdf, 0xd9, 0x1a, 0xed, 0x8e, 0xfa, 0xfb, 0xbb, 0xdd, 0x3a, 0xf6,
	0xfd, 0x6c, 0xf7, 0xa0, 0xdb, 0xc0, 0xc6, 0xd3, 0xfe, 0x4e, 0xb7, 0x89, 0xf4, 0x27, 0x5b, 0xc3,
	0xe1, 0xcf, 0x0e, 0xec, 0x9d, 0xae, 0x8e, 0xf3, 0x0e, 0x47, 0x76, 0x7f, 0xf0, 0x59, 0xd7, 0xc0,
	0xf6, 0xc1, 0xf6, 0xe3, 0xdd, 0x07, 0xa3, 0x2e, 0x58, 0xef, 0x41, 0xab, 0x70, 0x58, 0x1c, 0x6d,
	0xef, 0x3e, 0xec, 0x2e, 0xe1, 0x92, 0xcf, 0xb6, 0xf6, 0x9e, 0xee, 0x76, 0x35, 0xeb, 0xd7, 0x5a,
	0xde, 0x87, 0x2a, 0x0d, 0x1f, 0x82, 0xae, 0x58, 0x92, 0x85, 0xbe, 0xad, 0x02, 0xef, 0xec, 0x9c,
	0x58, 0xe6, 0x40, 0x75, 0x41, 0x1d, 0x31, 0xe2, 0x8a, 0x03, 0x5f, 0x70, 0xba, 0xec, 0xa8, 0x50,
	0x04, 0x15, 0xea, 0x59, 0xf5, 0x62, 0x3d, 0xeb, 0x71, 0x4d, 0xd7, 0xba, 0x15, 0x6b, 0x07, 0xf4,
	0x57, 0xd6, 0x98, 0xd4, 0x65, 0xa9, 0xcc, 0x83, 0xc8, 0x73, 0xaa, 0x4e, 0xd6, 0x97, 0x00, 0x0f,
	0xfd, 0x40, 0xb0, 0x64, 0x94, 0xb0, 0x4c, 0xa6, 0x72, 0x16, 0x94, 0xe9, 0x4d, 0xd0, 0xdd, 0x23,
	0x3f, 0xf0, 0x12, 0x16, 0xaa, 0xf3, 0x2d, 0xe3, 0xf9, 0xe6, 0x23, 0xec, 0x9c, 0x6e, 0xae, 0x43,
	0x8d, 0xca, 0x44, 0xd5, 0xb9, 0x29, 0xc8, 0x6b, 0x44, 0x44, 0xb1, 0x4e, 0xa1, 0x23, 0x5d, 0x99,
	0xba, 0xef, 0xaf, 0x72, 0x98, 0xe5, 0xdb, 0x51, 0x59, 0xbc, 0x1d, 0xc8, 0x9b, 0x43, 0x9f, 0x05,
	0x5e, 0x76, 0x1a, 0x05, 0xe1, 0xbd, 0x40, 0x4d, 0x96, 0xac, 0x34, 0x6c, 0x09, 0x58, 0x7f, 0xa3,
	0x01, 0xc8, 0xa5, 0x07, 0x91, 0xc7, 0xca, 0xa1, 0x9d, 0xb6, 0x18, 0xda, 0x99, 0x50, 0xcb, 0x6b,
	0x7d, 0x86, 0x4d, 0xed, 0xb9, 0x3d, 0x52, 0xe1, 0x9e, 0xb4, 0x47, 0xef, 0x82, 0x21, 0xa2, 0x63,
	0x16, 0xfa, 0x5f, 0x53, 0x02, 0x8e, 0x0b, 0xce, 0x11, 0xf3, 0xda, 0x88, 0x2c, 0x0b, 0xa8, 0xda,
	0xc8, 0x39, 0x05, 0x1d, 0x19, 0x2a, 0x73, 0x96, 0x88, 0x2c, 0x24, 0x94, 0x90, 0x75, 0x1f, 0xda,
	0x19, 0xc3, 0xa8, 0x30, 0x72, 0x33, 0x8f, 0x0e, 0xb4, 0xb9, 0x30, 0xe6, 0xe7, 0xda, 0xae, 0xf4,
	0xb4, 0x2c, 0x3e, 0xb0, 0xfe, 0xba, 0x92, 0x0d, 0x56, 0x89, 0xfa, 0xab, 0x0f, 0x5d, 0x8e, 0xcb,
	0x2a, 0x6f, 0x14, 0x97, 0x7d, 0x0a, 0x86, 0x47, 0x31, 0x8c, 0x7f, 0x92, 0x99, 0x9b, 0xd5, 0xc5,
	0x78, 0x45, 0x45, 0x39, 0xfe, 0x09, 0xb3, 0xe7, 0x9d, 0xdf, 0x94, 0x71, 0xf5, 0xf3, 0x18, 0xd7,
	0x38, 0x97, 0x71, 0xcd, 0x12, 0xe3, 0x6e, 0x81, 0x91, 0xaf, 0x5b, 0x88, 0x68, 0x0c, 0xa8, 0xf7,
	0x07, 0x3b, 0xbb, 0x3f, 0xef, 0x6a, 0x78, 0xf1, 0x77, 0x76, 0xf7, 0x76, 0x47, 0xbb, 0xdd, 0xaa,
	0xad, 0xb3, 0xd3, 0x38, 0xf0, 0x5d, 0x9f, 0xca, 0x88, 0xfb, 0x4e, 0xfc, 0x48, 0xd6, 0x50, 0xae,
	0xc3, 0x72, 0xec, 0x24, 0xc2, 0x47, 0x0d, 0x1e, 0x1f, 0xb3, 0x33, 0x99, 0x19, 0xb7, 0xed, 0x4e,
	0x8e, 0xfd, 0x9c, 0x9d, 0x71, 0xeb, 0x5f, 0x34, 0xb8, 0xb8, 0x1f, 0x9d, 0xb0, 0xdc, 0xe1, 0x3e,
	0x71, 0xce, 0x82, 0xc8, 0xf1, 0x5e, 0xc3, 0xf0, 0x2b, 0x00, 0x3c, 0x4a, 0x13, 0x97, 0x8d, 0xa7,
	0x59, 0x05, 0xc8, 0x36, 0x24, 0xe6, 0x33, 0x55, 0xb8, 0x65, 0x5c, 0x10, 0x51, 0x96, 0xa9, 0x9a,
	0x08, 0x23, 0xa9, 0xe0, 0xf3, 0x6a, 0x25, 0x9f, 0x77, 0xae, 0xfb, 0xae, 0xbf, 0xc4, 0x7d, 0x17,
	0xe3, 0xa9, 0x46, 0x39, 0x9e, 0xfa, 0x00, 0xda, 0x4f, 0x18, 0x4b, 0x6c, 0xc6, 0xe3, 0x28, 0xe4,
	0xac, 0x90, 0x11, 0x6a, 0x92, 0xcb, 0x12, 0xb2, 0x7e, 0x09, 0x06, 0x46, 0x7b, 0xdb, 0x8e, 0x70,
	0x8f, 0x7e, 0x48, 0x34, 0x78, 0x1d, 0x9a, 0xb1, 0xe4, 0x91, 0x8a, 0x81, 0xa4, 0xd1, 0x94, 0x28,
	0x3b, 0xa3, 0x59, 0x57, 0xa0, 0x99, 0xb1, 0xd2, 0x84, 0xda, 0x0e, 0xfa, 0x54, 0x59, 0x95, 0xa7,
	0xb6, 0x95, 0x00, 0x8c, 0x4e, 0xc3, 0xac, 0xf4, 0x57, 0xf4, 0x3e, 0xda, 0x2b, 0xbc, 0x4f, 0x65,
	0xc1, 0xf6, 0x62, 0x1e, 0x3c, 0xa1, 0xa7, 0x00, 0x75, 0xb5, 0x33, 0x10, 0xd7, 0x3c, 0x72, 0xf8,
	0x91, 0x0a, 0xaa, 0xa8, 0x6d, 0xfd, 0x45, 0x15, 0x9a, 0x05, 0xe3, 0xf5, 0xb2, 0x15, 0x2f, 0x42,
	0xfd, 0xab, 0x94, 0x25, 0x67, 0x59, 0xaa, 0x4c, 0x80, 0x79, 0x03, 0x6a, 0x27, 0x4e, 0x82, 0xd1,
	0x2b, 0xde, 0xdd, 0xb7, 0x89, 0x3d, 0x72, 0xae, 0xcd, 0x67, 0x4e, 0x56, 0x54, 0xa1, 0x2e, 0xb8,
	0xe5, 0x79, 0x2e, 0x28, 0x15, 0x7e, 0x9e, 0xf3, 0xad, 0x41, 0x6b, 0x82, 0xaa, 0xc1, 0x0e, 0x0f,
	0xa3, 0x5c, 0xf3, 0x01, 0x51, 0xbb, 0x84, 0x31, 0x6f, 0x16, 0xa3, 0xcc, 0x36, 0xad, 0xd6, 0x2e,
	0x46, 0x99, 0xe5, 0x20, 0x13, 0x14, 0x73, 0xc2, 0xe8, 0x39, 0xf9, 0x6d, 0xdd, 0x56, 0xec, 0x1a,
	0x44, 0xcf, 0xcd, 0x1f, 0x43, 0x2b, 0x61, 0x3c, 0x1e, 0x1f, 0x46, 0xc9, 0xcc, 0x11, 0xe4, 0xbb,
	0x97, 0xef, 0x5e, 0x2a, 0x6e, 0x1d, 0xb5, 0xe4, 0x21, 0x51, 0x6d, 0x48, 0xf2, 0x76, 0xce, 0xbd,
	0x0b, 0x73, 0xee, 0xad, 0xfe, 0x18, 0x8c, 0xfc, 0xa0, 0xe7, 0xd4, 0x38, 0x4a, 0x21, 0x8d, 0x51,
	0xac, 0x6b, 0xac, 0x01, 0xcc, 0x97, 0xc1, 0xfb, 0xfc, 0x78, 0x78, 0x30, 0x90, 0x19, 0x8a, 0xbd,
	0xf3, 0xb0, 0xab, 0x59, 0xab, 0x50, 0xa3, 0xca, 0x9d, 0x09, 0x35, 0x2a, 0xe8, 0x69, 0xd2, 0xc3,
	0x61, 0xdb, 0x7a, 0x1f, 0xda, 0xe8, 0xab, 0x0f, 0x0e, 0x87, 0x22, 0xc1, 0x58, 0x2a, 0x5f, 0x46,
	0x76, 0x92, 0x80, 0xf5, 0xbf, 0x15, 0xd0, 0x73, 0x85, 0x37, 0xa1, 0xf6, 0x25, 0x8f, 0xc2, 0x4c,
	0xdd, 0xb0, 0x6d, 0xae, 0x43, 0x55, 0x9c, 0x86, 0x4a, 0x61, 0xc9, 0xf0, 0xce, 0xb5, 0xcf, 0x46,
	0x12, 0xaa, 0x75, 0xe0, 0x08, 0x16, 0xba, 0x67, 0xca, 0x07, 0x92, 0x5a, 0xef, 0x49, 0x94, 0x9d,
	0xd1, 0xb0, 0xdb, 0x8c, 0x89, 0xc4, 0x77, 0xe5, 0xf5, 0x55, 0xdd, 0xf6, 0x25, 0xca, 0xce, 0x68,
	0xe6, 0x4d, 0x75, 0x14, 0x29, 0x3f, 0xc5, 0x72, 0xb9, 0xbf, 0x4d, 0x3c, 0xab, 0x52, 0x97, 0x54,
	0xd5, 0x24, 0x13, 0xef, 0x90, 0xa4, 0xd7, 0xb6, 0xb1, 0x89, 0xa3, 0x8f, 0xbc, 0x04, 0x83, 0xad,
	0x17, 0x47, 0x3f, 0xf2, 0x72, 0x65, 0xc3, 0x3e, 0x28, 0x96, 0x7c, 0xc2, 0x1f, 0x22, 0x96, 0xd5,
	0x3e, 0x18, 0xf9, 0x5c, 0xe7, 0x0c, 0xfc, 0xa0, 0x5c, 0xb3, 0xea, 0x66, 0x15, 0xfc, 0x4c, 0x12,
	0x45, 0x09, 0xff, 0xb7, 0x06, 0x7a, 0xa6, 0x9e, 0x74, 0xb3, 0x98, 0x18, 0x17, 0x44, 0xd0, 0xe4,
	0x4c, 0x3c, 0x46, 0x29, 0xac, 0x41, 0x4b, 0x65, 0x12, 0x44, 0x95, 0xc1, 0x2f, 0x48, 0x14, 0x75,
	0x40, 0xb3, 0xca, 0xc4, 0x38, 0xfc, 0x2a, 0x75, 0x3c, 0xae, 0x4a, 0x0f, 0x06, 0x67, 0x62, 0x40,
	0x08, 0x4a, 0x83, 0x59, 0x90, 0x91, 0x6b, 0x92, 0xec, 0xb1, 0x40, 0x91, 0x2f, 0x43, 0x95, 0x33,
	0xa1, 0x6e, 0x28, 0x3d, 0x8b, 0x0c, 0xbe, 0x48, 0x1d, 0xcf, 0x46, 0x2c, 0x12, 0x3d, 0x16, 0xf4,
	0x1a, 0x2f, 0x10, 0x3d, 0x16, 0xa0, 0xca, 0xb8, 0x51, 0x28, 0xab, 0xb5, 0x86, 0x4d, 0xed, 0x85,
	0xbb, 0xb5, 0xbc, 0x70, 0xb7, 0xac, 0x5f, 0x55, 0xc0, 0x38, 0x88, 0x59, 0x22, 0x0f, 0x7d, 0xa9,
	0xe0, 0xdb, 0x65, 0xd9, 0x4d, 0xe6, 0xf9, 0x97, 0x81, 0xd2, 0xf4, 0x71, 0xa1, 0xbe, 0xa2, 0x23,
	0x62, 0x4b, 0x88, 0x84, 0xbc, 0x04, 0x11, 0x83, 0x20, 0x33, 0x5f, 0x44, 0x0b, 0x82, 0x62, 0x7d,
	0xa0, 0x36, 0xaf, 0x0f, 0xe4, 0xeb, 0xbd, 0xba, 0x3e, 0x50, 0x5f, 0xa8, 0x0f, 0x98, 0x37, 0x61,
	0x25, 0x49, 0xc3, 0xb1, 0x1f, 0x8e, 0x27, 0x8e, 0x7b, 0x8c, 0x41, 0x5a, 0xe8, 0x29, 0xc3, 0x74,
	0x21, 0x49, 0xc3, 0x7e, 0xb8, 0x9d, 0xa3, 0xad, 0x3b, 0x6f, 0x54, 0x4b, 0xc0, 0xd6, 0xd6, 0x68,
	0x64, 0x77, 0xab, 0x56, 0x13, 0xea, 0xe4, 0x96, 0xac, 0xcb, 0xd0, 0x7c, 0xa6, 0xaa, 0x87, 0x5d,
	0xa8, 0x0a, 0x67, 0x9a, 0xa9, 0x93, 0x70, 0xa6, 0xd6, 0xdf, 0x69, 0xd0, 0x54, 0x97, 0x09, 0x77,
	0x1b, 0x3b, 0x09, 0xc7, 0xbc, 0x25, 0xcc, 0xac, 0xaf, 0xa1, 0x30, 0x03, 0x8e, 0xa9, 0x7e, 0x9c,
	0x44, 0x2e, 0xe3, 0x59, 0x0f, 0x95, 0xea, 0xcf, 0x91, 0x03, 0x8e, 0xaa, 0xc4, 0x42, 0x37, 0xf2,
	0x54, 0x17, 0x19, 0x94, 0x43, 0x86, 0x1a, 0x70, 0x73, 0x13, 0xde, 0x72, 0x38, 0xf7, 0xa7, 0xe1,
	0x3c, 0xab, 0xc7, 0x8e, 0xd2, 0xe7, 0xae, 0x48, 0x52, 0x9e, 0xda, 0x0f, 0xa8, 0xfc, 0x23, 0x22,
	0xe1, 0x04, 0xd8, 0x49, 0x55, 0x28, 0x08, 0x1e, 0x70, 0xeb, 0x6b, 0x68, 0xaa, 0x0b, 0x6e, 0xde,
	0x2b, 0xbc, 0x3b, 0xc8, 0x28, 0xae, 0x57, 0xb8, 0xff, 0x9b, 0x03, 0xf9, 0x06, 0xa1, 0xaa, 0xe4,
	0xea, 0x45, 0x62, 0xf5, 0x3e, 0xb4, 0x8b, 0x84, 0xd7, 0xdd, 0xd2, 0x52, 0xb5, 0xff, 0x1f, 0x34,
	0xa8, 0x93, 0xa2, 0xa2, 0xaf, 0xe3, 0xe9, 0xe4, 0x4b, 0xe6, 0x0a, 0x35, 0x32, 0x03, 0x5f, 0x53,
	0xeb, 0xbc, 0x0c, 0x46, 0x44, 0xfd, 0xc6, 0x2a, 0x18, 0x31, 0x6c, 0x5d, 0x22, 0xfa, 0x9e, 0x79,
	0x0b, 0xda, 0x8a, 0x28, 0xd7, 0x97, 0x36, 0xcd, 0xc8, 0x5f, 0x44, 0xed, 0x96, 0x24, 0x4b, 0x3d,
	0x2a, 0x95, 0xd9, 0xea, 0x0b, 0x65, 0x36, 0x0a, 0xf1, 0x9c, 0x70, 0x9a, 0xb9, 0x5c, 0x6c, 0x5b,
	0xff, 0x51, 0x81, 0xba, 0x1c, 0xfb, 0x1e, 0xde, 0xfd, 0x43, 0x27, 0x0d, 0x68, 0x29, 0x79, 0x84,
	0x47, 0x4b, 0x78, 0xfb, 0x09, 0xf9, 0xcc, 0x09, 0xcc, 0x2b, 0x60, 0x50, 0x49, 0x93, 0x3a, 0x90,
	0x71, 0x78, 0xb4, 0x64, 0xeb, 0x84, 0x42, 0xf2, 0x8f, 0xa0, 0xe9, 0x87, 0x72, 0x34, 0x1e, 0xa3,
	0xfa, 0x68, 0xc9, 0x6e, 0xf8, 0x21, 0x8d, 0xbc, 0x0c, 0xfa, 0x24, 0x8a, 0x02, 0xa2, 0x51, 0xd9,
	0xe9, 0xd1, 0x92, 0xdd, 0x44, 0x8c, 0x1a, 0xc7, 0x45, 0x42, 0xb4, 0xba, 0x5a, 0xb5, 0xc1, 0x45,
	0x82, 0xa4, 0x35, 0x00, 0x2f, 0x4a, 0x27, 0x01, 0x23, 0x2a, 0x6e, 0x5c, 0x7b, 0xb4, 0x64, 0x1b,
	0x12, 0xa7, 0xc6, 0x4e, 0x59, 0x44, 0xd4, 0xa6, 0xda, 0x50, 0x63, 0xca, 0x22, 0xb5, 0x26, 0x86,
	0xc8, 0x44, 0xd3, 0x15, 0xad, 0x89, 0x18, 0x24, 0x5e, 0x83, 0x36, 0x36, 0x51, 0xf5, 0xa8, 0x83,
	0xa1, 0x3a, 0xb4, 0x32, 0xac, 0xea, 0x14, 0x3b, 0x9c, 0x3f, 0x8f, 0x12, 0x8f, 0x3a, 0x81, 0xda,
	0x5d, 0x2b, 0xc3, 0xaa, 0x1d, 0xa4, 0xbe, 0xa4, 0x53, 0x2d, 0x07, 0x77, 0x90, 0xfa, 0x48, 0xda,
	0xae, 0xd3, 0xcf, 0x0e, 0xd6, 0x1f, 0x69, 0xd0, 0xde, 0x8b, 0xa6, 0x7e, 0x98, 0xc5, 0x36, 0x18,
	0x57, 0x73, 0x96, 0xa8, 0xb4, 0xcc, 0xb0, 0x15, 0x64, 0xae, 0x82, 0x9e, 0xcd, 0x9c, 0xd9, 0xa2,
	0x0c, 0xc6, 0x4b, 0x97, 0xb0, 0xc3, 0x84, 0xf1, 0xa3, 0x31, 0x85, 0xf2, 0x4a, 0x53, 0xda, 0x0a,
	0x39, 0x42, 0x5c, 0x59, 0xfe, 0xb5, 0xc5, 0x32, 0xeb, 0x2e, 0x54, 0x1f, 0x3f, 0x17, 0x78, 0xbb,
	0x1d, 0x17, 0x2f, 0xea, 0xf8, 0xcb, 0xe7, 0x99, 0xaa, 0x1a, 0x12, 0x83, 0xe4, 0x35, 0x8c, 0x49,
	0xe4, 0x42, 0x48, 0x97, 0xfb, 0x00, 0x85, 0x7a, 0xfc, 0x5c, 0x58, 0xbf, 0x07, 0xcb, 0xea, 0x6d,
	0x24, 0x73, 0xe8, 0x85, 0x27, 0x41, 0xed, 0xa5, 0x4f, 0x82, 0xd6, 0x14, 0x3a, 0xd9, 0x38, 0xc9,
	0x86, 0x37, 0x1a, 0xf6, 0xc3, 0x5f, 0x72, 0xad, 0x5f, 0xc2, 0x5b, 0xc3, 0x74, 0xc2, 0xdd, 0xc4,
	0x8f, 0x29, 0x1e, 0x53, 0xcb, 0x21, 0x77, 0x13, 0x76, 0xe8, 0x9f, 0xb2, 0x2c, 0xd5, 0xc8, 0x61,
	0xf3, 0x26, 0x34, 0x67, 0x18, 0x67, 0xb3, 0xac, 0xd0, 0xd0, 0x2d, 0x54, 0x04, 0xf7, 0x91, 0x62,
	0x67, 0x1d, 0xac, 0x9f, 0xc0, 0xc5, 0xf2, 0xf4, 0x8a, 0x0b, 0xd7, 0xa0, 0x7a, 0x7c, 0xc2, 0x55,
	0x78, 0xbe, 0x52, 0xaa, 0x28, 0xd2, 0xcb, 0x3a, 0x52, 0xad, 0xbf, 0xd7, 0xa0, 0x3a, 0x48, 0x67,
	0xc5, 0xff, 0x60, 0x6a, 0xf2, 0x3f, 0x98, 0x52, 0x50, 0x5a, 0x59, 0x08, 0x4a, 0xdf, 0x05, 0xe3,
	0x30, 0x4a, 0x9e, 0x3b, 0x89, 0x97, 0x47, 0xd2, 0x73, 0x04, 0x5e, 0xec, 0x49, 0x3a, 0x8b, 0x55,
	0x42, 0x47, 0x6d, 0xf3, 0xba, 0x4a, 0xb3, 0xa5, 0x77, 0x5a, 0x21, 0x7f, 0x9a, 0xce, 0x36, 0x03,
	0xe6, 0x70, 0x4a, 0x2f, 0x65, 0xe6, 0x6d, 0x7d, 0x04, 0x46, 0x8e, 0xc2, 0x04, 0x6e, 0x30, 0x1c,
	0xf7, 0x77, 0xa4, 0x47, 0x79, 0xda, 0xdf, 0x91, 0x99, 0xdc, 0xd3, 0xc1, 0xd3, 0xe1, 0xee, 0x4e,
	0xb7, 0x62, 0xfd, 0x02, 0x5a, 0x5b, 0x64, 0x97, 0x99, 0xd7, 0xf7, 0x28, 0xb8, 0xa7, 0x90, 0xbc,
	0xef, 0x95, 0x22, 0xf4, 0x3e, 0x95, 0xcf, 0x58, 0xe8, 0xf5, 0xbd, 0xcc, 0x5c, 0x12, 0x50, 0x3e,
	0xa1, 0xb4, 0x4e, 0xf9, 0x09, 0xad, 0x5d, 0x58, 0xb1, 0xe9, 0xa5, 0x06, 0x53, 0xed, 0xc2, 0x45,
	0x09, 0x23, 0x8f, 0xe5, 0x0b, 0x28, 0x08, 0x57, 0x56, 0xc2, 0x56, 0xa9, 0x5d, 0x2e, 0x7b, 0x06,
	0x2b, 0x98, 0x2d, 0x96, 0x15, 0xad, 0x74, 0x2d, 0xb4, 0x45, 0xb3, 0x78, 0x09, 0x1a, 0x52, 0xd7,
	0x94, 0xae, 0x2b, 0x08, 0xf5, 0xc5, 0xe3, 0xe2, 0xb3, 0xc2, 0xaf, 0x0c, 0x39, 0x6c, 0x3d, 0x84,
	0x76, 0x56, 0xe0, 0xdd, 0x67, 0x82, 0xc2, 0x08, 0x37, 0xf0, 0x4b, 0x75, 0x4b, 0x5d, 0x22, 0x46,
	0xe5, 0x87, 0x8b, 0x85, 0xed, 0x6e, 0x42, 0x63, 0x28, 0xdf, 0xff, 0x28, 0xc2, 0xf1, 0xe4, 0xf6,
	0xea, 0x36, 0xb5, 0x51, 0x49, 0x66, 0x7c, 0x9a, 0xd5, 0x98, 0x66, 0x7c, 0x6a, 0xfd, 0xb6, 0x02,
	0x9d, 0xdd, 0xd3, 0x98, 0x7e, 0xe6, 0x78, 0x6d, 0x91, 0xa7, 0x90, 0xc9, 0x56, 0x4a, 0x99, 0xec,
	0x3b, 0xd0, 0x4c, 0x43, 0xff, 0x34, 0x2b, 0x96, 0x55, 0xed, 0x06, 0x82, 0xb2, 0x54, 0xa6, 0x52,
	0x11, 0x99, 0x5a, 0x29, 0xc8, 0x5c, 0x47, 0xdf, 0xc0, 0x85, 0x1f, 0x52, 0x70, 0xa3, 0xe2, 0x97,
	0x22, 0xaa, 0x60, 0x54, 0xd0, 0x73, 0x36, 0x8a, 0x46, 0xe5, 0x73, 0x76, 0x26, 0xe3, 0x46, 0x37,
	0x61, 0x82, 0xc8, 0x4d, 0x49, 0x96, 0x18, 0x24, 0x5f, 0x83, 0x0e, 0xc7, 0xc8, 0x21, 0x0a, 0x95,
	0x71, 0x93, 0x2f, 0x28, 0x6d, 0x85, 0xcc, 0x8d, 0x9b, 0x13, 0x46, 0xe1, 0xd9, 0x2c, 0x4a, 0xe5,
	0x73, 0xb2, 0x6e, 0xcf, 0x11, 0x65, 0x19, 0xc3, 0xa2, 0xe9, 0xdb, 0x83, 0xe5, 0x8c, 0x6d, 0xf3,
	0x24, 0xe4, 0xf5, 0xfc, 0x96, 0xbf, 0x49, 0x05, 0x79, 0x01, 0x59, 0x02, 0xd6, 0xaf, 0x2b, 0xb0,
	0x2a, 0xeb, 0x2f, 0x9f, 0x25, 0x4e, 0x7c, 0xf4, 0xc5, 0xde, 0x0b, 0x75, 0xb7, 0x97, 0xa5, 0xae,
	0xd7, 0x61, 0x79, 0x8a, 0x43, 0xbe, 0x0a, 0xc6, 0x2a, 0x1c, 0x95, 0x8b, 0x75, 0x14, 0x56, 0x4e,
	0x64, 0xde, 0x83, 0xb6, 0x47, 0x18, 0x7a, 0x7d, 0x28, 0x3d, 0x6b, 0x95, 0x5e, 0xab, 0x5a, 0xb2,
	0x97, 0x7c, 0x63, 0xbb, 0x06, 0x9d, 0xc0, 0x99, 0x4d, 0x3c, 0x67, 0x2c, 0x6d, 0x93, 0x12, 0x53,
	0x5b, 0x22, 0x87, 0x84, 0x33, 0x3f, 0xa1, 0x12, 0x64, 0x83, 0x8c, 0xc2, 0x7b, 0x38, 0xdf, 0xcb,
	0xcf, 0xa1, 0xde, 0xf7, 0xac, 0x77, 0xe9, 0x75, 0x0e, 0xa0, 0x31, 0x7c, 0xf0, 0x68, 0x77, 0x7f,
	0x4b, 0x96, 0x8e, 0x87, 0x0f, 0xec, 0xfe, 0x93, 0x51, 0x57, 0xb3, 0xee, 0xc0, 0xe5, 0x73, 0xa7,
	0x50, 0x6c, 0x2e, 0x94, 0xd6, 0x6b, 0x54, 0x5a, 0xb7, 0x7e, 0xab, 0x81, 0xbe, 0x9d, 0x06, 0xc7,
	0x74, 0x6f, 0xae, 0x00, 0x30, 0x6f, 0xca, 0xd4, 0x2f, 0x74, 0x9a, 0x7a, 0x2a, 0xf0, 0xa6, 0x4c,
	0xfe, 0x44, 0x77, 0x1f, 0x40, 0xb2, 0x69, 0x2c, 0x7f, 0x3b, 0x44, 0x2e, 0x5c, 0xc6, 0x5d, 0x67,
	0x13, 0x28, 0x76, 0xec, 0x3b, 0xb1, 0x0c, 0xe9, 0x0c, 0x9e, 0xc1, 0xab, 0x03, 0x58, 0x2e, 0x13,
	0xdf, 0x30, 0x87, 0x2a, 0x31, 0xb8, 0x10, 0xe8, 0x3d, 0x86, 0x0b, 0x0b, 0x0f, 0x2a, 0xaf, 0xba,
	0x7b, 0x25, 0x75, 0xac, 0x2c, 0xaa, 0xe3, 0x2d, 0x58, 0x19, 0x39, 0xfc, 0x58, 0x5e, 0xfd, 0x6c,
	0xb6, 0x77, 0xd0, 0x1d, 0xf2, 0xe3, 0x71, 0xce, 0xae, 0x06, 0x82, 0x7d, 0xcf, 0xfa, 0x04, 0xcc,
	0x62, 0x6f, 0xc5, 0xd9, 0xcb, 0x60, 0x50, 0xf7, 0x19, 0x53, 0x95, 0x9b, 0x9a, 0xad, 0x23, 0x02,
	0xd9, 0x72, 0xf7, 0x9f, 0x34, 0xa8, 0xd9, 0xce, 0xa1, 0x30, 0x6f, 0x81, 0xf1, 0x88, 0x39, 0x89,
	0x98, 0x30, 0x47, 0x98, 0xc5, 0x42, 0xd0, 0x2a, 0x25, 0xd9, 0xf3, 0xdf, 0x19, 0xac, 0xa5, 0x8f,
	0x35, 0xf3, 0xb6, 0xfc, 0xe1, 0x2b, 0xfb, 0x91, 0xad, 0x93, 0xd5, 0x98, 0xa8, 0x06, 0xb5, 0x5a,
	0x1c, 0x6e, 0x2d, 0x6d, 0x50, 0xf7, 0xc7, 0x91, 0x1f, 0x3e, 0x08, 0x52, 0x2e, 0x58, 0x62, 0x2e,
	0x96, 0xa4, 0x16, 0x06, 0x98, 0xb7, 0xa1, 0xd1, 0xe7, 0x4f, 0xd8, 0x79, 0x3d, 0x89, 0xf3, 0xc5,
	0xaa, 0x98, 0xb5, 0x74, 0xf7, 0x8f, 0xeb, 0xd0, 0xf8, 0x59, 0x94, 0x1c, 0xb3, 0xc4, 0xbc, 0x01,
	0x0d, 0x4a, 0x5f, 0xd5, 0x96, 0xf2, 0xf7, 0xbc, 0xd5, 0x85, 0x4a, 0x81, 0xb5, 0x64, 0xbe, 0x0f,
	0xc6, 0x90, 0x25, 0xe8, 0x01, 0xf8, 0xb1, 0x49, 0x71, 0x32, 0xfd, 0xdb, 0xb9, 0x0a, 0x2a, 0x49,
	0x4f, 0x03, 0x41, 0x5b, 0x59, 0x1e, 0x8a, 0x84, 0x39, 0xb3, 0xfc, 0x55, 0xb3, 0xf4, 0x68, 0xb7,
	0xda, 0x44, 0xe8, 0xf3, 0x67, 0x43, 0x3c, 0xe6, 0xc7, 0x9a, 0x79, 0x03, 0x6a, 0xc3, 0x28, 0x11,
	0x72, 0xdf, 0x85, 0x5f, 0xfd, 0xe4, 0xfa, 0xf3, 0x7f, 0xeb, 0xac, 0x25, 0xf3, 0x0e, 0x34, 0xd4,
	0x25, 0x5e, 0x99, 0x6b, 0x93, 0x12, 0xf1, 0x6a, 0xb7, 0x88, 0x52, 0x03, 0x3e, 0x81, 0x86, 0x34,
	0x4d, 0x72, 0x40, 0xc9, 0xba, 0xaf, 0x9a, 0x45, 0x54, 0xc6, 0x19, 0xf3, 0x16, 0x74, 0x6d, 0xe6,
	0x32, 0xbf, 0x50, 0x15, 0x35, 0xb3, 0x1d, 0xbf, 0x28, 0xa5, 0x4f, 0xa1, 0x53, 0x2a, 0xa0, 0x9a,
	0x32, 0x23, 0x3a, 0xa7, 0xa6, 0xba, 0x28, 0xb0, 0x9f, 0x80, 0xa1, 0x22, 0x9d, 0x09, 0x33, 0xe9,
	0xd9, 0xea, 0x9c, 0xb8, 0x6a, 0xf5, 0xc5, 0x50, 0x87, 0x74, 0xe9, 0xe7, 0xf0, 0xd6, 0x39, 0x86,
	0xc1, 0xbc, 0xfa, 0x6a, 0xa3, 0xb3, 0xba, 0xf6, 0x52, 0x7a, 0x7e, 0xfc, 0xff, 0x97, 0xdf, 0xc4,
	0xdc, 0x87, 0x9f, 0xf7, 0xde, 0x29, 0x45, 0x2e, 0x6f, 0x8d, 0xb5, 0x64, 0xfe, 0x14, 0x60, 0x7e,
	0x8b, 0xcc, 0xb7, 0xb3, 0x9f, 0x56, 0x4b, 0x77, 0x70, 0xf5, 0xd2, 0x22, 0x3a, 0x5b, 0x74, 0xbb,
	0xf7, 0xcf, 0xdf, 0x5e, 0xd5, 0x7e, 0xf7, 0xed, 0x55, 0xed, 0xdf, 0xbf, 0xbd, 0xaa, 0xfd, 0xe9,
	0x77, 0x57, 0x97, 0x7e, 0xf7, 0xdd, 0xd5, 0xa5, 0x7f, 0xfb, 0xee, 0xea, 0xd2, 0xa4, 0x41, 0xbf,
	0x49, 0xdf, 0xfb, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xae, 0xca, 0x93, 0xcf, 0x93, 0x2d, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error)
	IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[0], "/pb.Raft/Heartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*HealthInfo, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*HealthInfo, error) {
	m := new(HealthInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[1], "/pb.Raft/RaftMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRaftMessageClient{stream}
	return x, nil
}

type Raft_RaftMessageClient interface {
	Send(*RaftBatch) error
	CloseAndRecv() (*Payload, error)
	grpc.ClientStream
}

type raftRaftMessageClient struct {
	grpc.ClientStream
}

func (x *raftRaftMessageClient) Send(m *RaftBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRaftMessageClient) CloseAndRecv() (*Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Raft/JoinCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error) {
	out := new(PeerResponse)
	err := c.cc.Invoke(ctx, "/pb.Raft/IsPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
type RaftServer interface {
	Heartbeat(*Payload, Raft_HeartbeatServer) error
	RaftMessage(Raft_RaftMessageServer) error
	JoinCluster(context.Context, *RaftContext) (*Payload, error)
	IsPeer(context.Context, *RaftContext) (*PeerResponse, error)
}

// UnimplementedRaftServer can be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (*UnimplementedRaftServer) Heartbeat(req *Payload, srv Raft_HeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (*UnimplementedRaftServer) RaftMessage(srv Raft_RaftMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method RaftMessage not implemented")
}
func (*UnimplementedRaftServer) JoinCluster(ctx context.Context, req *RaftContext) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}
func (*UnimplementedRaftServer) IsPeer(ctx context.Context, req *RaftContext) (*PeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPeer not implemented")
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*HealthInfo) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *HealthInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServer).RaftMessage(&raftRaftMessageServer{stream})
}

type Raft_RaftMessageServer interface {
	SendAndClose(*Payload) error
	Recv() (*RaftBatch, error)
	grpc.ServerStream
}

type raftRaftMessageServer struct {
	grpc.ServerStream
}

func (x *raftRaftMessageServer) SendAndClose(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRaftMessageServer) Recv() (*RaftBatch, error) {
	m := new(RaftBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_IsPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).IsPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/IsPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).IsPeer(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
		{
			MethodName: "IsPeer",
			Handler:    _Raft_IsPeer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RaftMessage",
			Handler:       _Raft_RaftMessage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb.proto",
}

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkerClient interface {
	// Data serving RPCs.
	Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*TxnContext, error)
	ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error)
	StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error)
	Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error)
	Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error)
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error)
	ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error)
	MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*Payload, error)
	Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Worker_SubscribeClient, error)
	UpdateGraphQLSchema(ctx context.Context, in *UpdateGraphQLSchemaRequest, opts ...grpc.CallOption) (*UpdateGraphQLSchemaResponse, error)
	DeleteNamespace(ctx context.Context, in *DeleteNsRequest, opts ...grpc.CallOption) (*Status, error)
	TaskStatus(ctx context.Context, in *TaskStatusRequest, opts ...grpc.CallOption) (*TaskStatusResponse, error)
}

type workerClient struct {
	cc *grpc.ClientConn
}

func NewWorkerClient(cc *grpc.ClientConn) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*TxnContext, error) {
	out := new(TxnContext)
	err := c.cc.Invoke(ctx, "/pb.Worker/Mutate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.Worker/ServeTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[0], "/pb.Worker/StreamSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerStreamSnapshotClient{stream}
	return x, nil
}

type Worker_StreamSnapshotClient interface {
	Send(*Snapshot) error
	Recv() (*KVS, error)
	grpc.ClientStream
}

type workerStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *workerStreamSnapshotClient) Send(m *Snapshot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerStreamSnapshotClient) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error) {
	out := new(SortResult)
	err := c.cc.Invoke(ctx, "/pb.Worker/Sort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error) {
	out := new(SchemaResult)
	err := c.cc.Invoke(ctx, "/pb.Worker/Schema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error) {
	out := new(ExportResponse)
	err := c.cc.Invoke(ctx, "/pb.Worker/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[1], "/pb.Worker/ReceivePredicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerReceivePredicateClient{stream}
	return x, nil
}

type Worker_ReceivePredicateClient interface {
	Send(*KVS) error
	CloseAndRecv() (*Payload, error)
	grpc.ClientStream
}

type workerReceivePredicateClient struct {
	grpc.ClientStream
}

func (x *workerReceivePredicateClient) Send(m *KVS) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerReceivePredicateClient) CloseAndRecv() (*Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Worker/MovePredicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Worker_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[2], "/pb.Worker/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_SubscribeClient interface {
	Recv() (*pb.KVList, error)
	grpc.ClientStream
}

type workerSubscribeClient struct {
	grpc.ClientStream
}

func (x *workerSubscribeClient) Recv() (*pb.KVList, error) {
	m := new(pb.KVList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) UpdateGraphQLSchema(ctx context.Context, in *UpdateGraphQLSchemaRequest, opts ...grpc.CallOption) (*UpdateGraphQLSchemaResponse, error) {
	out := new(UpdateGraphQLSchemaResponse)
	err := c.cc.Invoke(ctx, "/pb.Worker/UpdateGraphQLSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) DeleteNamespace(ctx context.Context, in *DeleteNsRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/pb.Worker/DeleteNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TaskStatus(ctx context.Context, in *TaskStatusRequest, opts ...grpc.CallOption) (*TaskStatusResponse, error) {
	out := new(TaskStatusResponse)
	err := c.cc.Invoke(ctx, "/pb.Worker/TaskStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServer is the server API for Worker service.
type WorkerServer interface {
	// Data serving RPCs.
	Mutate(context.Context, *Mutations) (*TxnContext, error)
	ServeTask(context.Context, *Query) (*Result, error)
	StreamSnapshot(Worker_StreamSnapshotServer) error
	Sort(context.Context, *SortMessage) (*SortResult, error)
	Schema(context.Context, *SchemaRequest) (*SchemaResult, error)
	Export(context.Context, *ExportRequest) (*ExportResponse, error)
	ReceivePredicate(Worker_ReceivePredicateServer) error
	MovePredicate(context.Context, *MovePredicatePayload) (*Payload, error)
	Subscribe(*SubscriptionRequest, Worker_SubscribeServer) error
	UpdateGraphQLSchema(context.Context, *UpdateGraphQLSchemaRequest) (*UpdateGraphQLSchemaResponse, error)
	DeleteNamespace(context.Context, *DeleteNsRequest) (*Status, error)
	TaskStatus(context.Context, *TaskStatusRequest) (*TaskStatusResponse, error)
}

// UnimplementedWorkerServer can be embedded to have forward compatible implementations.
type UnimplementedWorkerServer struct {
}

func (*UnimplementedWorkerServer) Mutate(ctx context.Context, req *Mutations) (*TxnContext, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mutate not implemented")
}
func (*UnimplementedWorkerServer) ServeTask(ctx context.Context, req *Query) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServeTask not implemented")
}
func (*UnimplementedWorkerServer) StreamSnapshot(srv Worker_StreamSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSnapshot not implemented")
}
func (*UnimplementedWorkerServer) Sort(ctx context.Context, req *SortMessage) (*SortResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sort not implemented")
}
func (*UnimplementedWorkerServer) Schema(ctx context.Context, req *SchemaRequest) (*SchemaResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schema not implemented")
}
func (*UnimplementedWorkerServer) Export(ctx context.Context, req *ExportRequest) (*ExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Export not implemented")
}
func (*UnimplementedWorkerServer) ReceivePredicate(srv Worker_ReceivePredicateServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceivePredicate not implemented")
}
func (*UnimplementedWorkerServer) MovePredicate(ctx context.Context, req *MovePredicatePayload) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MovePredicate not implemented")
}
func (*UnimplementedWorkerServer) Subscribe(req *SubscriptionRequest, srv Worker_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedWorkerServer) UpdateGraphQLSchema(ctx context.Context, req *UpdateGraphQLSchemaRequest) (*UpdateGraphQLSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGraphQLSchema not implemented")
}
func (*UnimplementedWorkerServer) DeleteNamespace(ctx context.Context, req *DeleteNsRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNamespace not implemented")
}
func (*UnimplementedWorkerServer) TaskStatus(ctx context.Context, req *TaskStatusRequest) (*TaskStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskStatus not implemented")
}

func RegisterWorkerServer(s *grpc.Server, srv WorkerServer) {
	s.RegisterService(&_Worker_serviceDesc, srv)
}

func _Worker_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Mutations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Mutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Mutate(ctx, req.(*Mutations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ServeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ServeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/ServeTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ServeTask(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).StreamSnapshot(&workerStreamSnapshotServer{stream})
}

type Worker_StreamSnapshotServer interface {
	Send(*KVS) error
	Recv() (*Snapshot, error)
	grpc.ServerStream
}

type workerStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *workerStreamSnapshotServer) Send(m *KVS) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerStreamSnapshotServer) Recv() (*Snapshot, error) {
	m := new(Snapshot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_Sort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SortMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Sort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Sort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Sort(ctx, req.(*SortMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Schema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Schema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Schema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Schema(ctx, req.(*SchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Export(ctx, req.(*ExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ReceivePredicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).ReceivePredicate(&workerReceivePredicateServer{stream})
}

type Worker_ReceivePredicateServer interface {
	SendAndClose(*Payload) error
	Recv() (*KVS, error)
	grpc.ServerStream
}

type workerReceivePredicateServer struct {
	grpc.ServerStream
}

func (x *workerReceivePredicateServer) SendAndClose(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerReceivePredicateServer) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_MovePredicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MovePredicatePayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).MovePredicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/MovePredicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).MovePredicate(ctx, req.(*MovePredicatePayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).Subscribe(m, &workerSubscribeServer{stream})
}

type Worker_SubscribeServer interface {
	Send(*pb.KVList) error
	grpc.ServerStream
}

type workerSubscribeServer struct {
	grpc.ServerStream
}

func (x *workerSubscribeServer) Send(m *pb.KVList) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_UpdateGraphQLSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGraphQLSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).UpdateGraphQLSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/UpdateGraphQLSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).UpdateGraphQLSchema(ctx, req.(*UpdateGraphQLSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/DeleteNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).DeleteNamespace(ctx, req.(*DeleteNsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).TaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/TaskStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).TaskStatus(ctx, req.(*TaskStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Worker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mutate",
			Handler:    _Worker_Mutate_Handler,
		},
		{
			MethodName: "ServeTask",
			Handler:    _Worker_ServeTask_Handler,
		},
		{
			MethodName: "Sort",
			Handler:    _Worker_Sort_Handler,
		},
		{
			MethodName: "Schema",
			Handler:    _Worker_Schema_Handler,
		},
		{
			MethodName: "Export",
			Handler:    _Worker_Export_Handler,
		},
		{
			MethodName: "MovePredicate",
			Handler:    _Worker_MovePredicate_Handler,
		},
		{
			MethodName: "UpdateGraphQLSchema",
			Handler:    _Worker_UpdateGraphQLSchema_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _Worker_DeleteNamespace_Handler,
		},
		{
			MethodName: "TaskStatus",
			Handler:    _Worker_TaskStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSnapshot",
			Handler:       _Worker_StreamSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ReceivePredicate",
			Handler:       _Worker_ReceivePredicate_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _Worker_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb.proto",
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SortedUids) > 0 {
		for iNdEx := len(m.SortedUids) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SortedUids[iNdEx]))
		}
		i = encodeVarintPb(dAtA, i, uint64(len(m.SortedUids)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bitmap) > 0 {
		i -= len(m.Bitmap)
		copy(dAtA[i:], m.Bitmap)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Bitmap)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TaskValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SrcFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SrcFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SrcFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsCount {
		i--
		if m.IsCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.First != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.First))
		i--
		dAtA[i] = 0x78
	}
	if m.Cache != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Cache))
		i--
		dAtA[i] = 0x70
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x68
	}
	if m.ExpandAll {
		i--
		if m.ExpandAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SrcFunc != nil {
		{
			size, err := m.SrcFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UidList != nil {
		{
			size, err := m.UidList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DoCount {
		i--
		if m.DoCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AfterUid != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AfterUid))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.List {
		i--
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IntersectDest {
		i--
		if m.IntersectDest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Counts) > 0 {
		dAtA4 := make([]byte, len(m.Counts)*10)
		var j3 int
		for _, num := range m.Counts {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPb(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValueMatrix) > 0 {
		for iNdEx := len(m.ValueMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValueMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UidMatrix) > 0 {
		for iNdEx := len(m.UidMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UidMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Desc {
		i--
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SortMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x68
	}
	if m.Offset != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Count != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UidMatrix) > 0 {
		for iNdEx := len(m.UidMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UidMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Order) > 0 {
		for iNdEx := len(m.Order) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Order[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SortResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for iNdEx := len(m.UidMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UidMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLearner {
		i--
		if m.IsLearner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SnapshotTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SnapshotTs))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x22
	}
	if m.Group != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x11
	}
	if len(m.WhoIs) > 0 {
		i -= len(m.WhoIs)
		copy(dAtA[i:], m.WhoIs)
		i = encodeVarintPb(dAtA, i, uint64(len(m.WhoIs)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LastUpdate != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x30
	}
	if m.AmDead {
		i--
		if m.AmDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Leader {
		i--
		if m.Leader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ZeroProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastCharged != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LastCharged))
		i--
		dAtA[i] = 0x48
	}
	if m.CpuHours != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHours))))
		i--
		dAtA[i] = 0x41
	}
	if m.DeleteNs != nil {
		{
			size, err := m.DeleteNs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x32
	}
	if m.NumNsids != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.NumNsids))
		i--
		dAtA[i] = 0x28
	}
	if m.NumUids != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.NumUids))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Tablets) > 0 {
		for iNdEx := len(m.Tablets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tablets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SnapshotTs) > 0 {
		for k := range m.SnapshotTs {
			v := m.SnapshotTs[k]
			baseI := i
			i = encodeVarintPb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MembershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MembershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastCharged != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LastCharged))
		i--
		dAtA[i] = 0x50
	}
	if m.CpuHours != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHours))))
		i--
		dAtA[i] = 0x49
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x42
	}
	if m.MaxNsID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxNsID))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxUID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxUID))
		i--
		dAtA[i] = 0x30
	}
	if m.RaftIndex != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RaftIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Removed) > 0 {
		dAtA8 := make([]byte, len(m.Removed)*10)
		var j7 int
		for _, num := range m.Removed {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPb(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tablets) > 0 {
		for k := range m.Tablets {
			v := m.Tablets[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Indexing) > 0 {
		for iNdEx := len(m.Indexing) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Indexing[iNdEx])
			copy(dAtA[i:], m.Indexing[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Indexing[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Ongoing) > 0 {
		for iNdEx := len(m.Ongoing) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ongoing[iNdEx])
			copy(dAtA[i:], m.Ongoing[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Ongoing[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x40
	}
	if m.LastEcho != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LastEcho))
		i--
		dAtA[i] = 0x38
	}
	if m.Uptime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Instance) > 0 {
		i -= len(m.Instance)
		copy(dAtA[i:], m.Instance)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Instance)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tablet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tablet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tablet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UncompressedBytes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UncompressedBytes))
		i--
		dAtA[i] = 0x58
	}
	if m.MoveTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MoveTs))
		i--
		dAtA[i] = 0x50
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.OnDiskBytes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.OnDiskBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DirectedEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectedEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectedEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Namespace != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Namespace))
		i--
		dAtA[i] = 0x58
	}
	if len(m.AllowedPreds) > 0 {
		for iNdEx := len(m.AllowedPreds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedPreds[iNdEx])
			copy(dAtA[i:], m.AllowedPreds[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.AllowedPreds[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Op != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x40
	}
	if m.ValueId != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ValueId))
		i--
		dAtA[i] = 0x29
	}
	if m.ValueType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Entity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Entity))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Mutations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mutations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DropValue) > 0 {
		i -= len(m.DropValue)
		copy(dAtA[i:], m.DropValue)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DropValue)))
		i--
		dAtA[i] = 0x42
	}
	if m.DropOp != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DropOp))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SinceTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x28
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.BaseTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BaseTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CheckpointTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CheckpointTs))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EntrySize != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EntrySize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Key != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x78
	}
	if m.DeleteNs != nil {
		{
			size, err := m.DeleteNs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.CdcState != nil {
		{
			size, err := m.CdcState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ExpectedChecksum != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ExpectedChecksum))
		i--
		dAtA[i] = 0x58
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x50
	}
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CleanPredicate) > 0 {
		i -= len(m.CleanPredicate)
		copy(dAtA[i:], m.CleanPredicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CleanPredicate)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Kv) > 0 {
		for iNdEx := len(m.Kv) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kv[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Mutations != nil {
		{
			size, err := m.Mutations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BaseTimestamp != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BaseTimestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDCState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDCState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDCState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SentTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SentTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KVS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Predicates[iNdEx])
			copy(dAtA[i:], m.Predicates[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Predicates[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Posting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Posting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Posting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x70
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x68
	}
	if m.Op != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x60
	}
	if m.PostingType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PostingType))
		i--
		dAtA[i] = 0x20
	}
	if m.ValType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *PostingList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostingList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PostingList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bitmap) > 0 {
		i -= len(m.Bitmap)
		copy(dAtA[i:], m.Bitmap)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Bitmap)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Splits) > 0 {
		dAtA18 := make([]byte, len(m.Splits)*10)
		var j17 int
		for _, num := range m.Splits {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintPb(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Postings) > 0 {
		for iNdEx := len(m.Postings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Postings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FilterTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterTree) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FilterTree) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Predicates[iNdEx])
			copy(dAtA[i:], m.Predicates[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Predicates[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Upsert {
		i--
		if m.Upsert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.List {
		i--
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Count {
		i--
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Tokenizer) > 0 {
		for iNdEx := len(m.Tokenizer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tokenizer[iNdEx])
			copy(dAtA[i:], m.Tokenizer[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Tokenizer[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Index {
		i--
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchemaResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchemaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Upsert {
		i--
		if m.Upsert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.List {
		i--
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Count {
		i--
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Tokenizer) > 0 {
		for iNdEx := len(m.Tokenizer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tokenizer[iNdEx])
			copy(dAtA[i:], m.Tokenizer[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Tokenizer[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Directive != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Directive))
		i--
		dAtA[i] = 0x18
	}
	if m.ValueType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MapHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartitionKeys) > 0 {
		for iNdEx := len(m.PartitionKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionKeys[iNdEx])
			copy(dAtA[i:], m.PartitionKeys[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.PartitionKeys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MovePredicatePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MovePredicatePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MovePredicatePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SinceTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x30
	}
	if m.ExpectedChecksum != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ExpectedChecksum))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x20
	}
	if m.DestGid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DestGid))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceGid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SourceGid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxnContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x32
	}
	if m.Aborted {
		i--
		if m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x7a
	}
	if m.RespFormat != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RespFormat))
		i--
		dAtA[i] = 0x70
	}
	if m.CommitNow {
		i--
		if m.CommitNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Mutations) > 0 {
		for iNdEx := len(m.Mutations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Mutations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.BestEffort {
		i--
		if m.BestEffort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Vars) > 0 {
		for k := range m.Vars {
			v := m.Vars[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x22
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Uids) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Uids) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Uids) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		for iNdEx := len(m.Uids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Uids[iNdEx])
			copy(dAtA[i:], m.Uids[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Uids[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListOfString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOfString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListOfString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hdrs) > 0 {
		for k := range m.Hdrs {
			v := m.Hdrs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Rdf) > 0 {
		i -= len(m.Rdf)
		copy(dAtA[i:], m.Rdf)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Rdf)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Uids) > 0 {
		for k := range m.Uids {
			v := m.Uids[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Latency != nil {
		{
			size, err := m.Latency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Mutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mutation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitNow {
		i--
		if m.CommitNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.Cond) > 0 {
		i -= len(m.Cond)
		copy(dAtA[i:], m.Cond)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cond)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Del) > 0 {
		for iNdEx := len(m.Del) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Del[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Set) > 0 {
		for iNdEx := len(m.Set) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Set[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DelNquads) > 0 {
		i -= len(m.DelNquads)
		copy(dAtA[i:], m.DelNquads)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DelNquads)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SetNquads) > 0 {
		i -= len(m.SetNquads)
		copy(dAtA[i:], m.SetNquads)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SetNquads)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeleteJson) > 0 {
		i -= len(m.DeleteJson)
		copy(dAtA[i:], m.DeleteJson)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DeleteJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SetJson) > 0 {
		i -= len(m.SetJson)
		copy(dAtA[i:], m.SetJson)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SetJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Operation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RunInBackground {
		i--
		if m.RunInBackground {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DropValue) > 0 {
		i -= len(m.DropValue)
		copy(dAtA[i:], m.DropValue)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DropValue)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DropOp != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DropOp))
		i--
		dAtA[i] = 0x20
	}
	if m.DropAll {
		i--
		if m.DropAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.DropAttr) > 0 {
		i -= len(m.DropAttr)
		copy(dAtA[i:], m.DropAttr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DropAttr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Check) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Latency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Latency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Latency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalNs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TotalNs))
		i--
		dAtA[i] = 0x28
	}
	if m.AssignTimestampNs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AssignTimestampNs))
		i--
		dAtA[i] = 0x20
	}
	if m.EncodingNs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EncodingNs))
		i--
		dAtA[i] = 0x18
	}
	if m.ProcessingNs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ProcessingNs))
		i--
		dAtA[i] = 0x10
	}
	if m.ParsingNs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ParsingNs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NumUids) > 0 {
		for k := range m.NumUids {
			v := m.NumUids[k]
			baseI := i
			i = encodeVarintPb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NQuad) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NQuad) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NQuad) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x32
	}
	if m.Namespace != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Namespace))
		i--
		dAtA[i] = 0x28
	}
	if m.ObjectValue != nil {
		{
			size, err := m.ObjectValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ObjectId) > 0 {
		i -= len(m.ObjectId)
		copy(dAtA[i:], m.ObjectId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.ObjectId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Val != nil {
		{
			size := m.Val.Size()
			i -= size
			if _, err := m.Val.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_DefaultVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DefaultVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DefaultVal)
	copy(dAtA[i:], m.DefaultVal)
	i = encodeVarintPb(dAtA, i, uint64(len(m.DefaultVal)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Value_BytesVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BytesVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesVal != nil {
		i -= len(m.BytesVal)
		copy(dAtA[i:], m.BytesVal)
		i = encodeVarintPb(dAtA, i, uint64(len(m.BytesVal)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Value_IntVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_IntVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPb(dAtA, i, uint64(m.IntVal))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Value_BoolVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BoolVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Value_StrVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_StrVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StrVal)
	copy(dAtA[i:], m.StrVal)
	i = encodeVarintPb(dAtA, i, uint64(len(m.StrVal)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *Value_DoubleVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DoubleVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleVal))))
	i--
	dAtA[i] = 0x31
	return len(dAtA) - i, nil
}
func (m *Value_GeoVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_GeoVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GeoVal != nil {
		i -= len(m.GeoVal)
		copy(dAtA[i:], m.GeoVal)
		i = encodeVarintPb(dAtA, i, uint64(len(m.GeoVal)))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Value_DateVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DateVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DateVal != nil {
		i -= len(m.DateVal)
		copy(dAtA[i:], m.DateVal)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DateVal)))
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Value_DatetimeVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DatetimeVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatetimeVal != nil {
		i -= len(m.DatetimeVal)
		copy(dAtA[i:], m.DatetimeVal)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DatetimeVal)))
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Value_PasswordVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_PasswordVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PasswordVal)
	copy(dAtA[i:], m.PasswordVal)
	i = encodeVarintPb(dAtA, i, uint64(len(m.PasswordVal)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *Value_UidVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_UidVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPb(dAtA, i, uint64(m.UidVal))
	i--
	dAtA[i] = 0x58
	return len(dAtA) - i, nil
}
func (m *LoginRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Namespace != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Namespace))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintPb(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Userid) > 0 {
		i -= len(m.Userid)
		copy(dAtA[i:], m.Userid)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Userid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Jwt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Jwt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Jwt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshJwt) > 0 {
		i -= len(m.RefreshJwt)
		copy(dAtA[i:], m.RefreshJwt)
		i = encodeVarintPb(dAtA, i, uint64(len(m.RefreshJwt)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessJwt) > 0 {
		i -= len(m.AccessJwt)
		copy(dAtA[i:], m.AccessJwt)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccessJwt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TabletResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TabletResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TabletResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tablets) > 0 {
		for iNdEx := len(m.Tablets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tablets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TabletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TabletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TabletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tablets) > 0 {
		for iNdEx := len(m.Tablets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tablets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for iNdEx := len(m.Matches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Matches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Prefixes) > 0 {
		for iNdEx := len(m.Prefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Prefixes[iNdEx])
			copy(dAtA[i:], m.Prefixes[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Prefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kvs != nil {
		{
			size, err := m.Kvs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Num) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Num) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Num) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bump {
		i--
		if m.Bump {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Forwarded {
		i--
		if m.Forwarded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Val != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Val))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssignedIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignedIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadOnly != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadOnly))
		i--
		dAtA[i] = 0x28
	}
	if m.EndId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EndId))
		i--
		dAtA[i] = 0x10
	}
	if m.StartId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveTabletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveTabletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveTabletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstGroup != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DstGroup))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Tablet) > 0 {
		i -= len(m.Tablet)
		copy(dAtA[i:], m.Tablet)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Tablet)))
		i--
		dAtA[i] = 0x12
	}
	if m.Namespace != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Namespace))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ClientTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Namespace != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Namespace))
		i--
		dAtA[i] = 0x50
	}
	if m.Anonymous {
		i--
		if m.Anonymous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SecretKey) > 0 {
		i -= len(m.SecretKey)
		copy(dAtA[i:], m.SecretKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SecretKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if m.UnixTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UnixTs))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Files[iNdEx])
			copy(dAtA[i:], m.Files[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Files[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGraphQLSchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGraphQLSchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGraphQLSchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LambdaScript) > 0 {
		i -= len(m.LambdaScript)
		copy(dAtA[i:], m.LambdaScript)
		i = encodeVarintPb(dAtA, i, uint64(len(m.LambdaScript)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DgraphPreds) > 0 {
		for iNdEx := len(m.DgraphPreds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DgraphPreds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GraphqlSchema) > 0 {
		i -= len(m.GraphqlSchema)
		copy(dAtA[i:], m.GraphqlSchema)
		i = encodeVarintPb(dAtA, i, uint64(len(m.GraphqlSchema)))
		i--
		dAtA[i] = 0x12
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGraphQLSchemaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGraphQLSchemaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGraphQLSchemaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BulkMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchemaMap) > 0 {
		for k := range m.SchemaMap {
			v := m.SchemaMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EdgeCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EdgeCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteNsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteNsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteNsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Namespace != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Namespace))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TaskStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TaskId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TaskStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TaskMeta != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TaskMeta))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bitmap)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.SortedUids) > 0 {
		n += 1 + sovPb(uint64(len(m.SortedUids)*8)) + len(m.SortedUids)*8
	}
	return n
}

func (m *TaskValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValType != 0 {
		n += 1 + sovPb(uint64(m.ValType))
	}
	return n
}

func (m *SrcFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.IsCount {
		n += 2
	}
	return n
}

func (m *Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.AfterUid != 0 {
		n += 9
	}
	if m.DoCount {
		n += 2
	}
	if m.UidList != nil {
		l = m.UidList.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SrcFunc != nil {
		l = m.SrcFunc.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ExpandAll {
		n += 2
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.Cache != 0 {
		n += 1 + sovPb(uint64(m.Cache))
	}
	if m.First != 0 {
		n += 1 + sovPb(uint64(m.First))
	}
	if m.Offset != 0 {
		n += 2 + sovPb(uint64(m.Offset))
	}
	return n
}

func (m *ValueList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.ValueMatrix) > 0 {
		for _, e := range m.ValueMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if m.IntersectDest {
		n += 2
	}
	if m.List {
		n += 2
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Desc {
		n += 2
	}
	return n
}

func (m *SortMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Order) > 0 {
		for _, e := range m.Order {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPb(uint64(m.Count))
	}
	if m.Offset != 0 {
		n += 1 + sovPb(uint64(m.Offset))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	return n
}

func (m *SortResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *RaftContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WhoIs)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Id != 0 {
		n += 9
	}
	if m.Group != 0 {
		n += 1 + sovPb(uint64(m.Group))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SnapshotTs != 0 {
		n += 1 + sovPb(uint64(m.SnapshotTs))
	}
	if m.IsLearner {
		n += 2
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Leader {
		n += 2
	}
	if m.AmDead {
		n += 2
	}
	if m.LastUpdate != 0 {
		n += 1 + sovPb(uint64(m.LastUpdate))
	}
	if m.Learner {
		n += 2
	}
	return n
}

func (m *ZeroProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SnapshotTs) > 0 {
		for k, v := range m.SnapshotTs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Tablets) > 0 {
		for _, e := range m.Tablets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.NumUids != 0 {
		n += 1 + sovPb(uint64(m.NumUids))
	}
	if m.NumNsids != 0 {
		n += 1 + sovPb(uint64(m.NumNsids))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.DeleteNs != nil {
		l = m.DeleteNs.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.CpuHours != 0 {
		n += 9
	}
	if m.LastCharged != 0 {
		n += 1 + sovPb(uint64(m.LastCharged))
	}
	return n
}

func (m *MembershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.Tablets) > 0 {
		for k, v := range m.Tablets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.Removed) > 0 {
		l = 0
		for _, e := range m.Removed {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if m.RaftIndex != 0 {
		n += 1 + sovPb(uint64(m.RaftIndex))
	}
	if m.MaxUID != 0 {
		n += 1 + sovPb(uint64(m.MaxUID))
	}
	if m.MaxNsID != 0 {
		n += 1 + sovPb(uint64(m.MaxNsID))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.CpuHours != 0 {
		n += 9
	}
	if m.LastCharged != 0 {
		n += 1 + sovPb(uint64(m.LastCharged))
	}
	return n
}

func (m *HealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Uptime != 0 {
		n += 1 + sovPb(uint64(m.Uptime))
	}
	if m.LastEcho != 0 {
		n += 1 + sovPb(uint64(m.LastEcho))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if len(m.Ongoing) > 0 {
		for _, s := range m.Ongoing {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Indexing) > 0 {
		for _, s := range m.Indexing {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Tablet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.OnDiskBytes != 0 {
		n += 1 + sovPb(uint64(m.OnDiskBytes))
	}
	if m.Remove {
		n += 2
	}
	if m.ReadOnly {
		n += 2
	}
	if m.MoveTs != 0 {
		n += 1 + sovPb(uint64(m.MoveTs))
	}
	if m.UncompressedBytes != 0 {
		n += 1 + sovPb(uint64(m.UncompressedBytes))
	}
	return n
}

func (m *DirectedEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != 0 {
		n += 9
	}
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovPb(uint64(m.ValueType))
	}
	if m.ValueId != 0 {
		n += 9
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	if len(m.AllowedPreds) > 0 {
		for _, s := range m.AllowedPreds {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Namespace != 0 {
		n += 1 + sovPb(uint64(m.Namespace))
	}
	return n
}

func (m *Mutations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.DropOp != 0 {
		n += 1 + sovPb(uint64(m.DropOp))
	}
	l = len(m.DropValue)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.BaseTs != 0 {
		n += 1 + sovPb(uint64(m.BaseTs))
	}
	if m.Done {
		n += 2
	}
	if m.SinceTs != 0 {
		n += 1 + sovPb(uint64(m.SinceTs))
	}
	return n
}

func (m *ZeroSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.CheckpointTs != 0 {
		n += 1 + sovPb(uint64(m.CheckpointTs))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseTimestamp != 0 {
		n += 1 + sovPb(uint64(m.BaseTimestamp))
	}
	if m.Mutations != nil {
		l = m.Mutations.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.CleanPredicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.ExpectedChecksum != 0 {
		n += 1 + sovPb(uint64(m.ExpectedChecksum))
	}
	if m.CdcState != nil {
		l = m.CdcState.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.DeleteNs != nil {
		l = m.DeleteNs.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Key != 0 {
		n += 1 + sovPb(uint64(m.Key))
	}
	if m.ReadTs != 0 {
		n += 2 + sovPb(uint64(m.ReadTs))
	}
	if m.CommitTs != 0 {
		n += 2 + sovPb(uint64(m.CommitTs))
	}
	if m.EntrySize != 0 {
		n += 2 + sovPb(uint64(m.EntrySize))
	}
	return n
}

func (m *CDCState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SentTs != 0 {
		n += 1 + sovPb(uint64(m.SentTs))
	}
	return n
}

func (m *KVS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Done {
		n += 2
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Posting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValType != 0 {
		n += 1 + sovPb(uint64(m.ValType))
	}
	if m.PostingType != 0 {
		n += 1 + sovPb(uint64(m.PostingType))
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	return n
}

func (m *PostingList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Postings) > 0 {
		for _, e := range m.Postings {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if len(m.Splits) > 0 {
		l = 0
		for _, e := range m.Splits {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	l = len(m.Bitmap)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *FilterTree) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Func != nil {
		l = m.Func.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *SchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SchemaNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index {
		n += 2
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count {
		n += 2
	}
	if m.List {
		n += 2
	}
	if m.Upsert {
		n += 2
	}
	return n
}

func (m *SchemaResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SchemaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovPb(uint64(m.ValueType))
	}
	if m.Directive != 0 {
		n += 1 + sovPb(uint64(m.Directive))
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count {
		n += 2
	}
	if m.List {
		n += 2
	}
	if m.Upsert {
		n += 2
	}
	return n
}

func (m *MapHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionKeys) > 0 {
		for _, b := range m.PartitionKeys {
			l = len(b)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *MovePredicatePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SourceGid != 0 {
		n += 1 + sovPb(uint64(m.SourceGid))
	}
	if m.DestGid != 0 {
		n += 1 + sovPb(uint64(m.DestGid))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.ExpectedChecksum != 0 {
		n += 1 + sovPb(uint64(m.ExpectedChecksum))
	}
	if m.SinceTs != 0 {
		n += 1 + sovPb(uint64(m.SinceTs))
	}
	return n
}

func (m *PeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *RaftBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *TxnContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if m.Aborted {
		n += 2
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Vars) > 0 {
		for k, v := range m.Vars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + 1 + len(v) + sovPb(uint64(len(v)))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.ReadOnly {
		n += 2
	}
	if m.BestEffort {
		n += 2
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.CommitNow {
		n += 2
	}
	if m.RespFormat != 0 {
		n += 1 + sovPb(uint64(m.RespFormat))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Uids) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		for _, s := range m.Uids {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *ListOfString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Latency != nil {
		l = m.Latency.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Uids) > 0 {
		for k, v := range m.Uids {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + 1 + len(v) + sovPb(uint64(len(v)))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	l = len(m.Rdf)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Hdrs) > 0 {
		for k, v := range m.Hdrs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Mutation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SetJson)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.DeleteJson)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SetNquads)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.DelNquads)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Del) > 0 {
		for _, e := range m.Del {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.Cond)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.CommitNow {
		n += 2
	}
	return n
}

func (m *Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.DropAttr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.DropAll {
		n += 2
	}
	if m.DropOp != 0 {
		n += 1 + sovPb(uint64(m.DropOp))
	}
	l = len(m.DropValue)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.RunInBackground {
		n += 2
	}
	return n
}

func (m *Check) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Latency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParsingNs != 0 {
		n += 1 + sovPb(uint64(m.ParsingNs))
	}
	if m.ProcessingNs != 0 {
		n += 1 + sovPb(uint64(m.ProcessingNs))
	}
	if m.EncodingNs != 0 {
		n += 1 + sovPb(uint64(m.EncodingNs))
	}
	if m.AssignTimestampNs != 0 {
		n += 1 + sovPb(uint64(m.AssignTimestampNs))
	}
	if m.TotalNs != 0 {
		n += 1 + sovPb(uint64(m.TotalNs))
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NumUids) > 0 {
		for k, v := range m.NumUids {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NQuad) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ObjectValue != nil {
		l = m.ObjectValue.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Namespace != 0 {
		n += 1 + sovPb(uint64(m.Namespace))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != nil {
		n += m.Val.Size()
	}
	return n
}

func (m *Value_DefaultVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DefaultVal)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *Value_BytesVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesVal != nil {
		l = len(m.BytesVal)
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}
func (m *Value_IntVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.IntVal))
	return n
}
func (m *Value_BoolVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_StrVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StrVal)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *Value_DoubleVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_GeoVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeoVal != nil {
		l = len(m.GeoVal)
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}
func (m *Value_DateVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DateVal != nil {
		l = len(m.DateVal)
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}
func (m *Value_DatetimeVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatetimeVal != nil {
		l = len(m.DatetimeVal)
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}
func (m *Value_PasswordVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PasswordVal)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *Value_UidVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.UidVal))
	return n
}
func (m *LoginRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Namespace != 0 {
		n += 1 + sovPb(uint64(m.Namespace))
	}
	return n
}

func (m *Jwt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessJwt)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.RefreshJwt)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *TabletResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tablets) > 0 {
		for _, e := range m.Tablets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *TabletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tablets) > 0 {
		for _, e := range m.Tablets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	return n
}

func (m *SubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, b := range m.Prefixes {
			l = len(b)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Matches) > 0 {
		for _, e := range m.Matches {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kvs != nil {
		l = m.Kvs.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Num) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != 0 {
		n += 1 + sovPb(uint64(m.Val))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.Forwarded {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovPb(uint64(m.Type))
	}
	if m.Bump {
		n += 2
	}
	return n
}

func (m *AssignedIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartId != 0 {
		n += 1 + sovPb(uint64(m.StartId))
	}
	if m.EndId != 0 {
		n += 1 + sovPb(uint64(m.EndId))
	}
	if m.ReadOnly != 0 {
		n += 1 + sovPb(uint64(m.ReadOnly))
	}
	return n
}

func (m *RemoveNodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovPb(uint64(m.NodeId))
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	return n
}

func (m *MoveTabletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Namespace != 0 {
		n += 1 + sovPb(uint64(m.Namespace))
	}
	l = len(m.Tablet)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.DstGroup != 0 {
		n += 1 + sovPb(uint64(m.DstGroup))
	}
	return n
}

func (m *SnapshotMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientTs != 0 {
		n += 1 + sovPb(uint64(m.ClientTs))
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPb(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *ExportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.UnixTs != 0 {
		n += 1 + sovPb(uint64(m.UnixTs))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Anonymous {
		n += 2
	}
	if m.Namespace != 0 {
		n += 1 + sovPb(uint64(m.Namespace))
	}
	return n
}

func (m *ExportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPb(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *UpdateGraphQLSchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	l = len(m.GraphqlSchema)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.DgraphPreds) > 0 {
		for _, e := range m.DgraphPreds {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.LambdaScript)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	return n
}

func (m *UpdateGraphQLSchemaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPb(uint64(m.Uid))
	}
	return n
}

func (m *BulkMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EdgeCount != 0 {
		n += 1 + sovPb(uint64(m.EdgeCount))
	}
	if len(m.SchemaMap) > 0 {
		for k, v := range m.SchemaMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DeleteNsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.Namespace != 0 {
		n += 1 + sovPb(uint64(m.Namespace))
	}
	return n
}

func (m *TaskStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovPb(uint64(m.TaskId))
	}
	return n
}

func (m *TaskStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskMeta != 0 {
		n += 1 + sovPb(uint64(m.TaskMeta))
	}
	return n
}

func sovPb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitmap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bitmap = append(m.Bitmap[:0], dAtA[iNdEx:postIndex]...)
			if m.Bitmap == nil {
				m.Bitmap = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.SortedUids = append(m.SortedUids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SortedUids) == 0 {
					m.SortedUids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.SortedUids = append(m.SortedUids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedUids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = append(m.Val[:0], dAtA[iNdEx:postIndex]...)
			if m.Val == nil {
				m.Val = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrcFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrcFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrcFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterUid", wireType)
			}
			m.AfterUid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterUid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoCount = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UidList == nil {
				m.UidList = &List{}
			}
			if err := m.UidList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcFunc == nil {
				m.SrcFunc = &SrcFunction{}
			}
			if err := m.SrcFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpandAll = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			m.First = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.First |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &TaskValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatrix = append(m.ValueMatrix, &ValueList{})
			if err := m.ValueMatrix[len(m.ValueMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntersectDest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntersectDest = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = append(m.Order, &Order{})
			if err := m.Order[len(m.Order)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhoIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhoIs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			m.SnapshotTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLearner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLearner = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Leader = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AmDead = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnapshotTs == nil {
				m.SnapshotTs = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SnapshotTs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tablets = append(m.Tablets, &Tablet{})
			if err := m.Tablets[len(m.Tablets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUids", wireType)
			}
			m.NumUids = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUids |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNsids", wireType)
			}
			m.NumNsids = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNsids |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteNs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteNs == nil {
				m.DeleteNs = &DeleteNsRequest{}
			}
			if err := m.DeleteNs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHours", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHours = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCharged", wireType)
			}
			m.LastCharged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastCharged |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[uint64]*Member)
			}
			var mapkey uint64
			var mapvalue *Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tablets == nil {
				m.Tablets = make(map[string]*Tablet)
			}
			var mapkey string
			var mapvalue *Tablet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tablet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tablets[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Removed = append(m.Removed, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Removed) == 0 {
					m.Removed = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Removed = append(m.Removed, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			m.RaftIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUID", wireType)
			}
			m.MaxUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNsID", wireType)
			}
			m.MaxNsID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNsID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHours", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHours = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCharged", wireType)
			}
			m.LastCharged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastCharged |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEcho", wireType)
			}
			m.LastEcho = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastEcho |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ongoing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ongoing = append(m.Ongoing, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexing = append(m.Indexing, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tablet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tablet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tablet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskBytes", wireType)
			}
			m.OnDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDiskBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveTs", wireType)
			}
			m.MoveTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedBytes", wireType)
			}
			m.UncompressedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectedEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectedEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectedEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			m.Entity = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueId", wireType)
			}
			m.ValueId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= DirectedEdge_Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPreds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedPreds = append(m.AllowedPreds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			m.Namespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Namespace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &DirectedEdge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &SchemaUpdate{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOp", wireType)
			}
			m.DropOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropOp |= Mutations_DropOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseTs", wireType)
			}
			m.BaseTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointTs", wireType)
			}
			m.CheckpointTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckpointTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseTimestamp", wireType)
			}
			m.BaseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mutations == nil {
				m.Mutations = &Mutations{}
			}
			if err := m.Mutations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &pb.KV{})
			if err := m.Kv[len(m.Kv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanPredicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CleanPredicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &Snapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedChecksum", wireType)
			}
			m.ExpectedChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedChecksum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdcState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CdcState == nil {
				m.CdcState = &CDCState{}
			}
			if err := m.CdcState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteNs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteNs == nil {
				m.DeleteNs = &DeleteNsRequest{}
			}
			if err := m.DeleteNs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrySize", wireType)
			}
			m.EntrySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntrySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDCState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDCState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDCState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTs", wireType)
			}
			m.SentTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SentTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Posting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Posting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Posting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostingType", wireType)
			}
			m.PostingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostingType |= Posting_PostingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostingList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostingList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostingList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Postings = append(m.Postings, &Posting{})
			if err := m.Postings[len(m.Postings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Splits = append(m.Splits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Splits) == 0 {
					m.Splits = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Splits = append(m.Splits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitmap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bitmap = append(m.Bitmap[:0], dAtA[iNdEx:postIndex]...)
			if m.Bitmap == nil {
				m.Bitmap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &FilterTree{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &Function{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenizer = append(m.Tokenizer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upsert = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &SchemaNode{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directive", wireType)
			}
			m.Directive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directive |= SchemaUpdate_Directive(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenizer = append(m.Tokenizer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upsert = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionKeys = append(m.PartitionKeys, make([]byte, postIndex-iNdEx))
			copy(m.PartitionKeys[len(m.PartitionKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MovePredicatePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MovePredicatePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MovePredicatePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGid", wireType)
			}
			m.SourceGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestGid", wireType)
			}
			m.DestGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestGid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedChecksum", wireType)
			}
			m.ExpectedChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedChecksum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aborted = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vars == nil {
				m.Vars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Vars[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestEffort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BestEffort = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &Mutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommitNow = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespFormat", wireType)
			}
			m.RespFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespFormat |= Request_RespFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Uids) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Uids: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Uids: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uids = append(m.Uids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOfString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOfString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOfString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = append(m.Json[:0], dAtA[iNdEx:postIndex]...)
			if m.Json == nil {
				m.Json = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &TxnContext{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latency == nil {
				m.Latency = &Latency{}
			}
			if err := m.Latency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uids == nil {
				m.Uids = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uids[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rdf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rdf = append(m.Rdf[:0], dAtA[iNdEx:postIndex]...)
			if m.Rdf == nil {
				m.Rdf = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdrs == nil {
				m.Hdrs = make(map[string]*ListOfString)
			}
			var mapkey string
			var mapvalue *ListOfString
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ListOfString{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Hdrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetJson = append(m.SetJson[:0], dAtA[iNdEx:postIndex]...)
			if m.SetJson == nil {
				m.SetJson = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteJson = append(m.DeleteJson[:0], dAtA[iNdEx:postIndex]...)
			if m.DeleteJson == nil {
				m.DeleteJson = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetNquads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetNquads = append(m.SetNquads[:0], dAtA[iNdEx:postIndex]...)
			if m.SetNquads == nil {
				m.SetNquads = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelNquads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelNquads = append(m.DelNquads[:0], dAtA[iNdEx:postIndex]...)
			if m.DelNquads == nil {
				m.DelNquads = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &NQuad{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Del", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Del = append(m.Del, &NQuad{})
			if err := m.Del[len(m.Del)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cond", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cond = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommitNow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropAll = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOp", wireType)
			}
			m.DropOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropOp |= Operation_DropOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunInBackground", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RunInBackground = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Latency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Latency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Latency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParsingNs", wireType)
			}
			m.ParsingNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParsingNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessingNs", wireType)
			}
			m.ProcessingNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessingNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingNs", wireType)
			}
			m.EncodingNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignTimestampNs", wireType)
			}
			m.AssignTimestampNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignTimestampNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNs", wireType)
			}
			m.TotalNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NumUids == nil {
				m.NumUids = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NumUids[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NQuad) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NQuad: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NQuad: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectValue == nil {
				m.ObjectValue = &Value{}
			}
			if err := m.ObjectValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			m.Namespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Namespace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = &Value_DefaultVal{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Val = &Value_BytesVal{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntVal", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &Value_IntVal{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Val = &Value_BoolVal{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = &Value_StrVal{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleVal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = &Value_DoubleVal{float64(math.Float64frombits(v))}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Val = &Value_GeoVal{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Val = &Value_DateVal{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatetimeVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Val = &Value_DatetimeVal{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = &Value_PasswordVal{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidVal", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &Value_UidVal{v}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			m.Namespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Namespace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Jwt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Jwt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Jwt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessJwt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessJwt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshJwt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshJwt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TabletResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TabletResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TabletResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tablets = append(m.Tablets, &Tablet{})
			if err := m.Tablets[len(m.Tablets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TabletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TabletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TabletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tablets = append(m.Tablets, &Tablet{})
			if err := m.Tablets[len(m.Tablets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, make([]byte, postIndex-iNdEx))
			copy(m.Prefixes[len(m.Prefixes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matches = append(m.Matches, &pb.Match{})
			if err := m.Matches[len(m.Matches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kvs == nil {
				m.Kvs = &pb.KVList{}
			}
			if err := m.Kvs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Num) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Num: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Num: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			m.Val = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Val |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forwarded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Forwarded = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NumLeaseType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bump", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bump = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartId", wireType)
			}
			m.StartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndId", wireType)
			}
			m.EndId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			m.ReadOnly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOnly |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveTabletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveTabletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveTabletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			m.Namespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Namespace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tablet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstGroup", wireType)
			}
			m.DstGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstGroup |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTs", wireType)
			}
			m.ClientTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTs", wireType)
			}
			m.UnixTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anonymous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Anonymous = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			m.Namespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Namespace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGraphQLSchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphqlSchema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphqlSchema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DgraphPreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DgraphPreds = append(m.DgraphPreds, &SchemaUpdate{})
			if err := m.DgraphPreds[len(m.DgraphPreds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LambdaScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= UpdateGraphQLSchemaRequest_Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGraphQLSchemaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeCount", wireType)
			}
			m.EdgeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaMap == nil {
				m.SchemaMap = make(map[string]*SchemaUpdate)
			}
			var mapkey string
			var mapvalue *SchemaUpdate
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SchemaUpdate{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SchemaMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteNsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteNsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteNsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			m.Namespace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Namespace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskMeta", wireType)
			}
			m.TaskMeta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskMeta |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPb = fmt.Errorf("proto: unexpected end of group")
)
